<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>技术知识wiki</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="way-api-wiki/基础支持/⭐️总结，先读此文.html"><strong aria-hidden="true">1.</strong> 先读此文</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Web服务器</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/WEB服务器/nginx使用ssl.html"><strong aria-hidden="true">2.1.</strong> Nginx使用SSL</a></li><li class="chapter-item expanded "><a href="way-api-wiki/WEB服务器/nginx本地开发加入ssl.html"><strong aria-hidden="true">2.2.</strong> Nginx本地开发加入SSL</a></li><li class="chapter-item expanded "><a href="way-api-wiki/WEB服务器/Tengine开启http2.html"><strong aria-hidden="true">2.3.</strong> Tengine开启http2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 服务器OS</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Alpine Linux</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/服务器OS/alpine/docker-rust镜像使用帮助.html"><strong aria-hidden="true">3.1.1.</strong> Docker Rust镜像使用帮助</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> CentOS</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/服务器OS/CentOS/CentOS7常见问题解决.html"><strong aria-hidden="true">3.2.1.</strong> CentOS7常见问题解决</a></li><li class="chapter-item expanded "><a href="way-api-wiki/服务器OS/CentOS/CentOS7日常操作命令.html"><strong aria-hidden="true">3.2.2.</strong> CentOS7日常操作命令</a></li><li class="chapter-item expanded "><a href="way-api-wiki/服务器OS/CentOS/CentOS7挖矿病毒清理.html"><strong aria-hidden="true">3.2.3.</strong> CentOS7挖矿病毒清理</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 桌面OS</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Manjaro</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/manjaro.html"><strong aria-hidden="true">4.1.1.</strong> Manjaro基本使用</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> MacOS</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS抓包.html"><strong aria-hidden="true">4.2.1.</strong> macOS抓包</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS显示Read-only file system的对应方法.html"><strong aria-hidden="true">4.2.2.</strong> macOS显示Read-only file system的对应方法</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS系统空间占用过大.html"><strong aria-hidden="true">4.2.3.</strong> macOS系统空间占用过大</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS我的软件.html"><strong aria-hidden="true">4.2.4.</strong> macOS我的软件</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS刷新DNS缓存.html"><strong aria-hidden="true">4.2.5.</strong> macOS刷新DNS缓存</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS使用fork的基本功能（git图形客户端）.html"><strong aria-hidden="true">4.2.6.</strong> macOS使用fork的基本功能（git图形客户端）</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS浏览器safari请求http跳转到https.html"><strong aria-hidden="true">4.2.7.</strong> macOS浏览器safari请求http跳转到https</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS不安装XCode使用CLion开发.html"><strong aria-hidden="true">4.2.8.</strong> macOS不安装XCode使用CLion开发</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 开发语言</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/Rust/Rust安装.html"><strong aria-hidden="true">5.1.1.</strong> Rust 安装</a></li><li class="chapter-item expanded "><a href="way-api-wiki/Rust/Rust常用语法总结.html"><strong aria-hidden="true">5.1.2.</strong> Rust常用语法总结</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Git</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/Git/GIT多Sshkeys管理.html"><strong aria-hidden="true">6.1.</strong> Git多ssh keys管理</a></li><li class="chapter-item expanded "><a href="way-api-wiki/Git/github相关链接访问慢、失效问题.html"><strong aria-hidden="true">6.2.</strong> github相关链接访问慢、失效问题</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">技术知识wiki</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p>基础支持是为了保障运行，方便工作。
以下软件，本地部署一律使用docker。</p>
</blockquote>
<h2><a class="header" href="#内部支持" id="内部支持">内部支持</a></h2>
<table><thead><tr><th>内部支持</th><th>软件</th><th>描述</th><th>替代软件</th></tr></thead><tbody>
<tr><td>内部管理</td><td>钉钉</td><td>提供人员管理、打卡、年假等等各种常备的OA功能。</td><td><a href="https://github.com/o2oa/o2oa">O2OA</a></td></tr>
<tr><td>内部沟通</td><td>钉钉</td><td>提供消息交流、群功能。至于能不能被监控，出于安全考虑，最好独立部署</td><td><a href="https://gitlab.com/superxzl/way-api/wikis/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81/rocket.chat">rocket.chat</a></td></tr>
<tr><td>邮件管理</td><td>钉钉</td><td>内置免费50人的邮件功能，但出于安全考虑，最好单独部署邮件服务器。</td><td><a href="https://gitlab.com/superxzl/way-api/wikis/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81/mailserver">mailserver</a></td></tr>
<tr><td>操作系统</td><td><a href="https://manjaro.org">Manjaro</a></td><td>Manjaro是一个基于Arch Linux的开源发行版本。该软件继承了所有当前高端前沿软件的优点：不仅启动速度快，而且自动化程度高、人工干预少，但能在需要的时候提供必要的帮助。</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#开发语言" id="开发语言">开发语言</a></h2>
<table><thead><tr><th>语言</th><th>描述</th><th>使用场景</th></tr></thead><tbody>
<tr><td>java8</td><td>Java reduces costs, shortens developer timeframes, drives innovation, and improves application services as the programming language of choice for enterprise architecture, finance, and HR. Java is used in many industries including manufacturing, automotive, insurance, and public sector.</td><td>企业业务等</td></tr>
<tr><td>GoLang</td><td>Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.</td><td>高并发、基础框架等，如k8s/docker</td></tr>
<tr><td>Rust</td><td>Empowering everyone to build reliable and efficient software.</td><td>底层技术，计算等</td></tr>
<tr><td>TypeScript</td><td><em>TypeScript</em> brings you optional static type-checking along with the latest ECMAScript features.</td><td>前端开发</td></tr>
</tbody></table>
<h2><a class="header" href="#开发支持" id="开发支持">开发支持</a></h2>
<table><thead><tr><th>开发支持</th><th>软件</th><th>描述</th><th>替代软件</th></tr></thead><tbody>
<tr><td>JDK</td><td>Amazon Corretto 8</td><td>Oracle JDK的后续补丁更新需要收费。Amazon的云业务实际排名第一，jdk的使用量也非常多，支持免费维护是最佳的选择。</td><td><a href="http://openjdk.java.net">OpenJDK</a></td></tr>
<tr><td>代码管理</td><td>gitlab-ee</td><td>gitlab的企业版本，功能强大，本地部署。</td><td><a href="https://github.com/gogs/gogs">gogs</a>，gitea</td></tr>
<tr><td>开发协作</td><td>Confluence</td><td>多人文档协作，有大量的插件资源，可以与钉钉进行关联</td><td><a href="https://github.com/Requarks/wiki">wiki.js</a></td></tr>
<tr><td>知识管理</td><td><a href="https://github.com/Requarks/wiki">wiki.js</a></td><td>这是一个简单实用的wiki</td><td></td></tr>
<tr><td>开发管理</td><td>Jira</td><td>项目管理，有大量插件资源，可以与钉钉进行关联</td><td></td></tr>
<tr><td>数据库</td><td>PostgreSQL</td><td>数据库管理系统</td><td>MySQL8</td></tr>
<tr><td>开发框架</td><td>SpringBoot2</td><td>java开发框架</td><td>其中tomcat可替换为undertow</td></tr>
<tr><td>私服仓库</td><td>Sonatype Nexus</td><td>maven仓库，jar包管理，npm、rpm等。也可以作为docker私服，暂时不做。</td><td></td></tr>
<tr><td>docker私服</td><td>Harbor</td><td>docker images都将存储于此</td><td></td></tr>
<tr><td>SQL审核平台</td><td><a href="https://github.com/hhyo/Archery">Archery</a></td><td>SQL审核执行平台，redis</td><td><a href="https://github.com/cookieY/Yearning-go">Yearning-go</a></td></tr>
<tr><td>全链路监测</td><td>SkyWalking / PinPoint</td><td>监测线上运行程序执行顺序、时间、效率等。（<strong>注：两个开源应用各有各的特点，需要使用时再看当时版本的最新特性对比</strong>）</td><td></td></tr>
<tr><td>ServerLess</td><td>OpenFaas</td><td>无服务函数。可以将一小段代码部署在服务上，web程序可以直接调用。</td><td></td></tr>
<tr><td>CI/CD</td><td>gitlab CI</td><td>持续集成、持续交付（部署）。<strong>如果gitlab CI受限于性能，可使用别的开源产品</strong></td><td>Drone Jenkins Tekton Concourse GoCD</td></tr>
<tr><td>代码审查</td><td>gitlab merge request</td><td>gitlab中自带的代码请求合并功能</td><td>gerrit</td></tr>
<tr><td><del>MySQL数据同步</del></td><td><del><a href="https://github.com/zendesk/maxwell">Maxwell</a></del></td><td><del>读取mysql的binlog，将行更新数据作为json发布到kafka、redis等生产工具，待订阅者对数据进行消费。</del></td><td>debezium优先。 <del>canal</del>（<del>不会使用的，只做展示，除非有重大变革</del>）</td></tr>
<tr><td>变动数据捕捉（CDC）</td><td><a href="https://github.com/debezium/debezium">debezium</a></td><td>Debezium是一个开源项目，它为变更数据捕获（CDC）提供了一个低延迟的数据流平台。您可以设置和配置Debezium来监视数据库，然后应用程序为数据库的每一行级更改使用事件。只有提交的更改才可见，因此应用程序不必担心事务或回滚的更改。Debezium提供了所有变更事件的单一模型，因此您的应用程序不必担心每种数据库管理系统的复杂性。此外，由于Debezium将数据更改的历史记录在持久的复制日志中，因此您的应用程序可以随时停止和重新启动，并且它将能够使用未运行时丢失的所有事件，从而确保所有事件都得到正确和完全的处理。 <em>PostgreSQL和MySQL都支持</em></td><td></td></tr>
<tr><td>前端服务器</td><td>deno</td><td>deno是一个基于v8、rust和Tokio的Javascript/Typescript的安全运行时。它在内部嵌入了一个typescript的编译器。可以将typescript编译成js然后运行在v8上，并通过c++ libdeno实现js与rust的通信交互，当然deno也可以直接运行Javascript代码。</td><td>nodejs（可互换）</td></tr>
</tbody></table>
<h2><a class="header" href="#运维服务" id="运维服务">运维服务</a></h2>
<table><thead><tr><th>运维服务</th><th>软件</th><th>描述</th><th align="left">替代软件</th></tr></thead><tbody>
<tr><td>基础服务器OS</td><td>Ubuntu Server</td><td>Ubuntu的服务器版本</td><td align="left">Rocky Linux</td></tr>
<tr><td>docker镜像OS</td><td>Alpine</td><td>最安全、体积极小的linux版本</td><td align="left"></td></tr>
<tr><td>CMDB资产管理</td><td></td><td></td><td align="left"></td></tr>
<tr><td>堡垒机</td><td>Teleport</td><td>Teleport是一款简单易用的<strong>开源堡垒机系统</strong>，具有小巧、易用的特点，支持 RDP/SSH/SFTP/Telnet 协议的远程连接和审计管理。</td><td align="left"></td></tr>
<tr><td>运维平台</td><td><a href="https://www.ansible.com">ansible</a></td><td>运维管理平台，可视化管理ansible tower</td><td align="left"><a href="https://www.saltstack.com/">Salt Stack</a></td></tr>
<tr><td>编排部署</td><td>k8s &amp; docker</td><td>服务器部署，产品、stag和开发都统一使用。rancher或kubesphere管理k8s</td><td align="left"></td></tr>
<tr><td>容器管理</td><td>podman</td><td>Podman是一个无守护进程容器引擎，用于在Linux系统上开发、管理和运行OCI容器。容器可以作为root运行，也可以以无root模式运行。简单地说：alias docker=podman。</td><td align="left">docker</td></tr>
<tr><td>容器http服务器</td><td>Traefik</td><td>Træfɪk 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具。</td><td align="left"></td></tr>
<tr><td>http服务器</td><td>nginx</td><td><em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP/POP3/SMTP<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1/100571">服务</a>。</td><td align="left">caddy</td></tr>
<tr><td>分布式文件系统</td><td><a href="https://github.com/sjqzhang/go-fastdfs">go-fastdfs</a></td><td>go-fastdfs 是一个简单的分布式文件系统(私有云存储)，具有无中心、高性能，高可靠，免维护等优点，支持断点续传，分块上传，小文件合并，自动同步，自动修复。</td><td align="left">GlusterFS</td></tr>
<tr><td>配置存储</td><td>etcd</td><td>etcd是用于共享配置和服务发现的分布式，一致性的KV存储系统。</td><td align="left">consul</td></tr>
<tr><td>OSS</td><td>MinIO</td><td>MinIO 是一个基于Apache License v2.0开源协议的对象存储服务。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。</td><td align="left">ceph</td></tr>
<tr><td>MQ</td><td>Pulsar</td><td>Apache Pulsar是一个开源的分布式pub-sub消息传递系统，最初创建于Yahoo，现在是Apache软件基金会的一部分</td><td align="left">Kafka</td></tr>
<tr><td>定时任务</td><td>xxl-job</td><td>一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。</td><td align="left"><a href="https://github.com/PowerJob/PowerJob">PowerJob</a></td></tr>
<tr><td>全文搜索</td><td>ElasticSearch</td><td>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。</td><td align="left"><a href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a>（<strong>刚刚起步不久</strong>）<br><a href="https://github.com/valeriansaliou/sonic">Sonic</a></td></tr>
<tr><td>日志搜集</td><td>ELK</td><td>“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。</td><td align="left"><a href="https://github.com/grafana/loki">Loki</a>，可直接替换</td></tr>
<tr><td>服务网格Service      Mesh</td><td>linkerd2</td><td>Linkerd2 （曾命名为 <a href="https://conduit.io/">Conduit</a>） 是 Buoyant 公司推出的下一代轻量级服务网格框架，开源在 https://github.com/linkerd/linkerd2。与 linkerd 不同的是，它专用于 Kubernetes 集群中，并且比 linkerd 更轻量级（基于 Rust 和 Go，没有了 JVM 等大内存的开销），可以以 sidecar 的方式把代理服务跟实际服务的 Pod 运行在一起（这点跟 Istio 类似）。Linkerd2 的主要特性包括：<br>· 轻量级，速度快，每个代理容器仅占用 10mb RSS，并且额外延迟只有亚毫妙级<br>· 安全，基于 Rust，默认开启 TLS<br>· 端到端可视化<br>· 增强 Kubernetes 的可靠性、可视性以及安全性</td><td align="left">istio，都可互换</td></tr>
<tr><td>机密管理</td><td>Vault</td><td>用于机密管理、加密即服务和特权访问管理的工具</td><td align="left"></td></tr>
</tbody></table>
<h2><a class="header" href="#额外支持" id="额外支持">额外支持</a></h2>
<table><thead><tr><th>名称</th><th>软件</th><th>描述</th><th>替代软件</th></tr></thead><tbody>
<tr><td>博客</td><td>Jekyll</td><td>将纯文本转换为静态博客网站</td><td>Hexo、Zola</td></tr>
<tr><td>BI</td><td>Metabase</td><td>一个简单、开源的方式,通过给公司成员提问,从得到的数据中进行分析、学习。</td><td></td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#nginx使用ssl" id="nginx使用ssl">nginx使用ssl</a></h2>
<h3><a class="header" href="#使用certbot-auto配置ssl" id="使用certbot-auto配置ssl">使用certbot-auto配置ssl</a></h3>
<h4><a class="header" href="#首次生成证书" id="首次生成证书">首次生成证书</a></h4>
<p>使用免费的Let's encrypt获取证书并让nginx使用，具体如下</p>
<ol>
<li>
<p>安装certbot-auto</p>
<pre><code class="language-shell">wget https://dl.eff.org/certbot-auto
chmod a+x ./certbot-auto
./certbot-auto --help
</code></pre>
</li>
<li>
<p>生成证书</p>
<pre><code class="language-shell">sudo ./certbot-auto certonly --preferred-challenges dns --manual --email geniusmickymouse@qq.com --server https://acme-v02.api.letsencrypt.org/directory -d jicu.vip -d *.jicu.vip
</code></pre>
<p>生成证书过程中需要对指定的域名添加DNS解析信息（一共两条）</p>
<pre><code>_acme-challenge TXT 默认 记录值（填入一长串字母加数字）
</code></pre>
<p>添加DNS完成后，再继续，直到提示完成。</p>
</li>
</ol>
<hr />
<h4><a class="header" href="#nginx配置证书" id="nginx配置证书">nginx配置证书</a></h4>
<ol>
<li>在nginx的conf文件夹中，创建文件<code>ssl.conf</code></li>
</ol>
<pre><code class="language-nginx">ssl_certificate       /etc/letsencrypt/live/jicu.vip/fullchain.pem;
ssl_certificate_key   /etc/letsencrypt/live/jicu.vip/privkey.pem;
</code></pre>
<p>将<code>ssl.conf</code>引入到其它域名配置文件www.conf中</p>
<pre><code class="language-nginx">server{
  listen       80;
  server_name  www.jicu.vip;
  return       301 https://$server_name$request_uri;
}
server {
	listen 443 ssl;
	server_name www.jicu.vip;
	include /usr/local/nginx/conf/ssl.conf;
	location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$ {
		root            /apps/web/assets;
		expires         30d;
  }

	location / {
		root   /apps/web/www;
		index  index.html index.htm;
		expires 30d;
  }
}
</code></pre>
<p>检查<code>nginx -t</code>配置是否准确，然后重启<code>nginx -s reload</code>。==检查服务器443端口是否开启。==</p>
<ol start="3">
<li>访问域名www.jicu.vip是否正常，如果不正常问问百度。</li>
</ol>
<h4><a class="header" href="#配置域名自动续期" id="配置域名自动续期">配置域名自动续期</a></h4>
<ol>
<li>
<p>先配置两个环境变量，最好写在/etc/profile，或者.bashrc里面，然后执行source生效</p>
<pre><code class="language-shell"># 阿里云的access key和secret,这个可以是ram子账户授权
export CERTBOT_ALI_KEY=&quot;&quot;
export CERTBOT_ALI_SECRET=&quot;&quot;
</code></pre>
</li>
<li>
<p>下载certbot-alidns放到/usr/bin/，并改名为<code>certbot-alidns</code></p>
<pre><code>编译好的下载，Linux版本,其他版本请自行编译；
链接: https://pan.baidu.com/s/1zk3iM-KTbJr941frtFYJkw 提取码: uxe5
</code></pre>
</li>
<li>
<p>加入定时任务重新生成证书，先编辑一个运行脚本<code>cert-renew.sh</code></p>
<pre><code class="language-bash">#!/bin/bash
# 停止nginx
#nginx -s stop

# 续签
sudo /apps/software/certbot-auto renew --force-renew --cert-name jicu.vip --manual-auth-hook /usr/bin/certbot-alidns &amp;&amp; /usr/local/nginx/sbin/nginx -s reload

# 重启nginx
#nginx -s reload
</code></pre>
<p>写入定时任务</p>
<pre><code class="language-shell"># 编辑定时任务
crontab -e

# 写入定时任务。每周日，凌晨3点执行重新生成证书脚本
* 3 * * 0 /apps/script/cert-renew.sh &gt;&gt; /apps/log/crontab/cert-renew-$(date +&quot;\%Y-\%m-\%d&quot;).log 2&gt;&amp;1

# 查看定时任务列表
crontab -l
</code></pre>
</li>
<li>
<p>手动重新生成证书，==如果有紧急情况==</p>
<pre><code class="language-shell">sudo /apps/software/certbot-auto renew --force-renew --cert-name jicu.vip --manual-auth-hook /usr/bin/certbot-alidns &amp;&amp; /usr/local/nginx/sbin/nginx -s reload
</code></pre>
</li>
<li>
<p>访问http://s.tool.chinaz.com/https/检查<code>SSL</code>过期时间是否更新</p>
</li>
</ol>
<h3><a class="header" href="#使用acmesh配置ssl" id="使用acmesh配置ssl">使用acme.sh配置ssl</a></h3>
<ol>
<li>
<p>安装。查看<a href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E">官方说明</a>。<em>如果是第一次使用，最好阅读一遍</em></p>
</li>
<li>
<p>安装完成后，重启一个命令行窗口<code>alias acme.sh</code>才起作用。</p>
</li>
<li>
<p>配置对应域名运营商的api key。不知道如何配置，查看<a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">官方说明dnsapi</a></p>
</li>
<li>
<p>申请证书。执行命令<code>acme.sh --issue --dns dns_ali -d jicu.vip -d *.jicu.vip</code>。</p>
<ul>
<li>泛域名必须使用<code>--dns</code>来申请，否则会提示<code>The supported validation types are dns-01,but you specified http-01</code>，不同的服务提供商参数值会不同，这里是<code>dns_ali</code>阿里的。</li>
<li>如果出现错误并看不到信息，在命令后面加入<code>--log</code>、<code>--debug</code>或<code>--debug 2</code>，后一个比前一个日志详细度更高。</li>
</ul>
</li>
<li>
<p>安装证书。执行命令<code>acme.sh --install-cert -d jicu.vip \ --key-file       /etc/letsencrypt/live/jicu.vip/privkey.pem  \ --fullchain-file /etc/letsencrypt/live/jicu.vip/fullchain.pem \ --reloadcmd     &quot;/usr/local/nginx/sbin/nginx -s reload&quot;</code></p>
</li>
<li>
<p>打开浏览器查看自己的域名证书是否正常。</p>
</li>
<li>
<p>由于let's encrypt会不定时修改策略，acme.sh也会进行跟进更新，为了防止再次使用acme.sh发生未知问题，使用之前最好进行升级，执行命令<code>acme.sh --upgrade</code></p>
</li>
</ol>
<p>提示：打开<code>https://crt.sh</code>，可以查看证书<strong>申请次数</strong>和<strong>起止时间</strong>是否==正常==。</p>
<h2><a class="header" href="#nginx本地开发加入ssl" id="nginx本地开发加入ssl">nginx本地开发加入ssl</a></h2>
<ol>
<li>
<p>安装<code>openssl</code></p>
</li>
<li>
<p>执行命令</p>
</li>
</ol>
<pre><code class="language-shell"># 用openssl生成key和crt文件
&gt; openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /apps/cert/nginx.key -out /apps/cert/nginx.crt
</code></pre>
<ol start="3">
<li>填写注册内容</li>
</ol>
<pre><code class="language-shell">Country Name (2 letter code) [XX]: CN
State or Province Name (full name) []: beijing    
Locality Name (eg, city) [Default City]: beijing
Organization Name (eg, company) [Default Company Ltd]: 回车
Organizational Unit Name (eg, section) []: 回车
Common Name (eg, your name or your server's hostname) []: *.jicu.vip
Email Address []: geniusmickymouse@qq.com
</code></pre>
<p>注：hostname使用**<code>*.jicu.vip</code><strong>代表泛域名。也可以使用</strong>localhost**。</p>
<ol start="4">
<li>配置nginx</li>
</ol>
<pre><code class="language-nginx">server {
  listen 443 ssl;
  server_name  mp.jicu.vip;

  ssl_certificate /apps/cert/nginx.crt;
  ssl_certificate_key /apps/cert/nginx.key;

  location / {
    root /apps/web/mp;
    index index.html;
  }
}
</code></pre>
<ol start="5">
<li>校验nginx配置，重启</li>
</ol>
<pre><code class="language-shell"># 校验
&gt; nginx -t
nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok
nginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful

# 重启
&gt; nginx -s reload
</code></pre>
<ol start="6">
<li>浏览器访问<code>https://mp.jicu.vip</code>，会有提示（不同浏览器不同），继续（强制）访问。</li>
<li>如果代码中调用<code>https://api.jicu.vip</code>等其它的服务，需要按照==步骤6==在浏览器地址栏中访问一次。</li>
</ol>
<p>本文结束！</p>
<h2><a class="header" href="#为什么要用http2" id="为什么要用http2">为什么要用Http2</a></h2>
<p>提升性能。自行baidu获取答案。</p>
<h2><a class="header" href="#tengine追加使用http2" id="tengine追加使用http2">Tengine追加使用Http2</a></h2>
<ol>
<li>
<p>获取Tengine源码，<code>git clone https://github.com/alibaba/tengine.git</code></p>
</li>
<li>
<p>执行编译</p>
<pre><code class="language-shell">cd tengine

./configure --with-http_ssl_module --with-http_v2_module # 如果还有其他参数也加上

make
</code></pre>
</li>
<li>
<p>检验结果</p>
<pre><code class="language-shell">cd objs

./nginx -v
Tengine version: Tengine/x.x.x (nginx/x.x.x) # 提示：x.x.x为版本号

./nginx -V
结果列表有 ngx_http_v2_module (static) 代表 HTTP/2 编译模块通过
</code></pre>
</li>
<li>
<p>替换旧nginx</p>
<pre><code class="language-shell"># 当前还在objs目录
sudo cp -f nginx /usr/local/nginx/sbin
</code></pre>
</li>
<li>
<p>进入nginx配置文件，启用http2</p>
<pre><code class="language-shell"># listen 443 ssl;
# 改为
listen 443 http2 ssl;
</code></pre>
</li>
<li>
<p>保存配置文件，检查是否正确<code>nginx -t</code>，然后重启<code>nginx -s reload</code></p>
</li>
<li>
<p>右键打开safari浏览器的<code>检查元素</code>，访问或刷新要启用http2的域名，在<code>网络</code>一栏里，对应的域名的有一列<code>协议</code>（如果没有就右键添加进去）显示h2证明启用成功。<em><strong>如果还是http/1.1，说明没有启用成功，看看nginx是否重启正确。</strong></em></p>
</li>
</ol>
<blockquote>
<p>alpine docker</p>
</blockquote>
<h2><a class="header" href="#请求rust镜像" id="请求rust镜像">请求rust镜像</a></h2>
<pre><code class="language-shell">&gt; docker pull rust:alpine
</code></pre>
<h2><a class="header" href="#加入国内cargo镜像源" id="加入国内cargo镜像源">加入国内cargo镜像源</a></h2>
<pre><code class="language-shell">&gt; vi cargo_temp_config
# 写入
[source.crates-io]
replace-with='ustc'

[source.ustc]
registry=&quot;https://mirrors.ustc.edu.cn/crates.io-index&quot;

&gt; docker run -it -v ./cargo_temp_config:/.cargo/config rust:alpine 
# ⚠️此处如果使用$HOME/.cargo/config将不起作用
</code></pre>
<h3><a class="header" href="#dockerfile" id="dockerfile">dockerfile</a></h3>
<pre><code class="language-dockerfile"># 重新制作一个新的docker image
FROM rust:alpine
# 修改alpine源为ustc
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories
# 避免cargo编译时出现问题
ENV CARGO_HTTP_MULTIPLEXING false
# 加入cargo国内源的配置文件
RUN mkdir /.cargo
ADD ./cargo_temp_config /.cargo/config
</code></pre>
<p>执行命令<code>docker build -t rust_alpine .</code>构建镜像</p>
<h3><a class="header" href="#多阶段构建镜像" id="多阶段构建镜像">多阶段构建镜像</a></h3>
<pre><code class="language-dockerfile">FROM rust:alpine as builder
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories
ENV CARGO_HTTP_MULTIPLEXING false
RUN mkdir /.cargo
ADD ./cargo_temp_config /.cargo/config
RUN apk add git
RUN git clone https://xxx.xxx.xxx/xxx/xxx # 改为自己的仓库地址
RUN cd xxx
RUN cargo build --release

FROM rust:alpine
COPY --from=builder /build_source/target/release/xxx .
CMD [&quot;./xxx&quot;]
</code></pre>
<p>执行命令<code>docker build -t rust_alpine .</code>构建镜像</p>
<h2><a class="header" href="#cargo-install编译中出现的问题" id="cargo-install编译中出现的问题">cargo install编译中出现的问题</a></h2>
<table><thead><tr><th align="left">问题</th><th>解决</th></tr></thead><tbody>
<tr><td align="left">= note: /usr/lib/gcc/x86_64-alpine-linux-musl/9.3.0/../../../../x86_64-alpine-linux-musl/bin/ld: cannot find crti.o: No such file or directory<br/>          collect2: error: ld returned 1 exit status</td><td>apk add --no-cache -U musl-dev</td></tr>
</tbody></table>
<h2><a class="header" href="#克隆源代码" id="克隆源代码">克隆源代码</a></h2>
<pre><code class="language-shell">&gt; apk add git
# Git安装完成

&gt; git clone https://xxx...
</code></pre>
<h2><a class="header" href="#crontab-error-renaming解决办法" id="crontab-error-renaming解决办法">crontab: error renaming解决办法</a></h2>
<blockquote>
<p>因为挖矿病毒，某些文件加入了chattr +i权限</p>
</blockquote>
<p>执行 crontab -e 命令，系统显示类似如下。</p>
<pre><code class="language-shell">[root@iZkZ cron]# crontab -e
crontab: installing new crontab
crontab: error renaming /var/spool/cron/#tmp.xx.XXXX3tTwiC to /var/spool/cron/root
rename: Operation not permitted
crontab: edits left in /tmp/crontab.BRY7dw
</code></pre>
<p>解决方法：进入<code>cd /var/spool/cron</code>，执行命令<code>chattr -i root</code>，修改/var/spool/cron/root权限。
然后执行<code>crontab -e</code>命令，系统显示类似如下，表示恢复正常。
crontab: installing new crontab</p>
<p>执行完，再将权限改回来<code>chattr +i root</code></p>
<p>原文链接：https://blog.csdn.net/qq_29485643/java/article/details/89072025</p>
<h2><a class="header" href="#centos7-修改密码不需要重启" id="centos7-修改密码不需要重启">CentOS7 修改密码，不需要重启</a></h2>
<h4><a class="header" href="#修改密码" id="修改密码">修改密码</a></h4>
<pre><code class="language-shell"># 输入passwd，再输入两次新密码后，立即生效
&gt; passwd
</code></pre>
<h2><a class="header" href="#centos7定时任务" id="centos7定时任务">CentOS7定时任务</a></h2>
<p>cron服务是Linux的内置服务，但它不会开机自动启动，可以每分钟执行任务。可以用以下命令启动和停止服务：</p>
<pre><code class="language-shell">systemctl start crond
systemctl stop crond
systemctl restart crond
systemctl reload crond
systemctl status crond
</code></pre>
<p>添加开机启动</p>
<pre><code class="language-shell">vi /etc/rc.local

/bin/systemctl start crond.service
</code></pre>
<p><strong>crontab操作</strong></p>
<pre><code class="language-shell">crontab -u //设定某个用户的cron服务 
crontab -l //列出某个用户cron服务的详细内容 
crontab -r //删除某个用户的cron服务 
crontab -e //编辑某个用户的cron服务
crontab -i //打印提示，输入yes等确认信息

/var/spool/cron/root (以用户命名的文件) 是所有默认存放定时任务的文件
/etc/cron.deny 该文件中所列出用户不允许使用crontab命令
/etc/cron.allow 该文件中所列出用户允许使用crontab命令，且优先级高于/etc/cron.deny

/var/log/cron    该文件存放cron服务的日志
</code></pre>
<p><strong>基本格式</strong></p>
<pre><code class="language-shell"># For details see man 4 crontabs
# Example of job definition:
# .---------------- minute (0 - 59)
# | .------------- hour (0 - 23)
# | | .---------- day of month (1 - 31)
# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...
# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# | | | | |
# * * * * * user-name command to be executed
定时任务的每段为：分，时，日，月，周，用户，命令
第1列表示分钟1～59 每分钟用*或者 */1表示
第2列表示小时1～23（0表示0点）
第3列表示日期1～31
第4列表示月份1～12
第5列标识号星期0～6（0表示星期天）
第6列要运行的命令

*：表示任意时间都，实际上就是“每”的意思。可以代表00-23小时或者00-12每月或者00-59分
-：表示区间，是一个范围，00 17-19 * * * cmd，就是每天17,18,19点的整点执行命令
,：是分割时段，30 3,19,21 * * * cmd，就是每天凌晨3和晚上19,21点的半点时刻执行命令
/n：表示分割，可以看成除法，*/5 * * * * cmd，每隔五分钟执行一次
</code></pre>
<p>https://www.cnblogs.com/p0st/p/9482167.html</p>
<h1><a class="header" href="#挖矿病毒清理" id="挖矿病毒清理">挖矿病毒清理</a></h1>
<blockquote>
<p>中了多次挖矿病毒，一直找不到中的原因，只能被动查找并删除。阿里云的服务器是不是有漏洞？除了系统暴露的端口之外，曾经只开了一个MySQL：3306端口，中了netflix病毒之后就关闭了。</p>
</blockquote>
<h2><a class="header" href="#第一种伪装netflix挖矿病毒" id="第一种伪装netflix挖矿病毒">第一种：伪装netflix挖矿病毒</a></h2>
<ol>
<li><code>top</code>，查看哪个进程CPU高。一般有两个<code>netflix</code>和<code>yqgnnb</code></li>
<li><code>lsof -p 进程id</code>，根据信息找出病毒目录进行删除。有一个.sazh的路径，全部删除</li>
<li>删除<code>/tmp</code>目录所有内容，有些硬炮无法删除，执行<code>lsattr</code>，如有<code>---------i------------</code>，那么执行<code>chattr -i *</code>，解除权限后，再执行删除</li>
<li><code>kill -9 netflix</code></li>
<li><code>kill -9 yqgnnb</code></li>
<li>查看<code>/var/spool/cron/root</code>是否有定时任务来启动挖矿脚本</li>
</ol>
<h2><a class="header" href="#第二种watchdogs挖矿病毒" id="第二种watchdogs挖矿病毒">第二种：watchdogs挖矿病毒</a></h2>
<blockquote>
<p>这种病毒较为常见，网上搜索有专门的解决方案和清理脚本。我只记录几个关键的命令和路径。</p>
</blockquote>
<ul>
<li>
<p><code>lsattr</code>查看当前文件夹内的程序权限。<strong>目的是找出有--------------i-------------的病毒文件</strong></p>
</li>
<li>
<p><code>chattr -i 程序名</code>解除-----------i-------------权限</p>
</li>
<li>
<p><code>/etc/rc.d/init.d</code>此目录有两个挖矿病毒<code>watchdogs</code>和<code>kthrotlds</code>，删除它</p>
</li>
<li>
<p><code>rm /usr/local/lib/libioset.so</code>删除此文件</p>
</li>
<li>
<p><code>cd /tmp</code>并<code>rm -rf *</code>删除/tmp内的文件</p>
</li>
<li>
<p>查看<code>/var/spool/cron/root</code>是否有定时任务来启动挖矿脚本</p>
<p>参考：https://www.secpulse.com/archives/99420.html</p>
</li>
</ul>
<h2><a class="header" href="#manjaro文档" id="manjaro文档">manjaro文档</a></h2>
<blockquote>
<p>本文档只为工作相关进行编写。</p>
</blockquote>
<h3><a class="header" href="#manjaro简介" id="manjaro简介">manjaro简介</a></h3>
<p>​		Manjaro是一个基于Arch Linux的开源发行版本。该软件继承了所有当前高端前沿软件的优点：不仅启动速度快，而且自动化程度高、人工干预少，但能在需要的时候提供必要的帮助。</p>
<p>​		Manjaro是一个优秀的走进Linux世界的入口。不像专用操作系统，您可以不受限制地完全控制硬件。对于那些想学习Linux的工作原理以及它与其他操作系统的不同之处的人来说，Manjaro是理想的选择。从这个角度来看，它也适合初学者。</p>
<p>​		Manjaro能通过使用兼容性软件，例如Wine或PlayonLinux轻松运行许多流行的Windows应用程序。</p>
<p>​		Manjaro不是面向消费者的操作系统。您拥有完全的控制权，可以对自己安装的程序进行破坏性的操作而系统也不会加以阻止。当然，修复这些破坏性的操作也是一种乐趣！另一方面，如果您对Manjaro的工作方式感到满意，则无需进行任何更改。</p>
<p>​		另外，对于经验丰富的Linux用户而言，Manjaro代表了理想的中间地带。他们既需要良好的性能，全面的控制和尖端的软件，又需要一定程度的软件版本稳定性。</p>
<h3><a class="header" href="#manjaro-特点" id="manjaro-特点">Manjaro 特点</a></h3>
<ul>
<li>
<p>免费 Manjaro永远完全免费。我们创建它，是为了让我们拥有一个易于使用且稳定的基于Linux的操作系统，而作为用户的您，需要知道的是我们不会失去对您的控制并尊重您的隐私。</p>
</li>
<li>
<p>资源丰富 软件中心提供了数千种软件应用程序，其中包括与流行的Windows软件（如MS Office）完全兼容的等效软件。任何软件也是完全免费的。无需在网上搜索直接安装即可。</p>
</li>
<li>
<p>社区完善 我们有一个气氛友好的论坛，在那里每个人都将会受到欢迎。该论坛是与所有人共享知识、交流Linux的合适场所。</p>
</li>
<li>
<p>可用性 Manjaro可用于64位体系结构。官方支持XFCE，KDE和Gnome版本。其它版本，包括32位体系结构的版本，是由社区维护。</p>
</li>
</ul>
<h3><a class="header" href="#manjaro-特色" id="manjaro-特色">Manjaro 特色</a></h3>
<ul>
<li>
<p>易于控制</p>
<ul>
<li>
<p>更新自由 当系统（包括软件）有更新时，系统仅提示有更新可用。系统不会自动在后台自动下载，安装和重启。</p>
</li>
<li>
<p>自由的数据安全策略 Manjaro不会将任何数据发送给任何人。您的数据只有您可以决定如何处理。</p>
</li>
<li>
<p>方便定制 Manjaro带有默认设置，我们认为它对大多数用户有用。但是，与大多数Linux发行版一样，您仍然可以选择配置，更改，删除或替换所需的任何选项。这些选项中的大多数都可以通过易于使用的配置程序直接获得。</p>
</li>
</ul>
</li>
<li>
<p>一键配置</p>
<ul>
<li>
<p>安装软件简单 Manjaro维护自己的程序（安装，更新和删除）时，只需打开它，选择所需的内容，然后单击“安装”即可。所有其他需要的软件包将自动安装，您要做的就是启动程序。</p>
</li>
<li>
<p>语言包丰富 只需在系统中启动区域设置，然后选择所需的语言即可。登出并再次登录后，一切都随您所愿。系统还提供了一种特殊的工具，可以自动为各种程序安装语言包，并翻译自己关心的程序。</p>
</li>
<li>
<p>显卡驱动安装简单 Manjaro附带MHWD（Manjaro硬件检测）。如果您需要用于硬件的驱动程序，只需打开它，单击“自动安装”，然后等待完成即可。而已。</p>
</li>
<li>
<p>切换内核简单 高级用户和需要Linux内核的特殊功能（而不是默认功能）的人员只需单击一下即可切换到其他内核。您制作音乐还是需要其他实时功能？只需切换到RT内核即可。您是否需要最新改进的开源图形驱动程序？只需切换到较新的版本即可。 Manjaro同时支持多个已安装的内核。只需重新引导系统，然后在引导菜单中进行选择即可。</p>
</li>
<li>
<p>……</p>
</li>
</ul>
</li>
<li>
<p>用户受众面广</p>
<p>Manjaro是满足您各种需求的高效伴侣。用户从家庭用户到学生和老师，从程序员和开发人员到专业人士，艺术爱好者，音乐爱好者，多媒体专业人员等等。 在这里，在大多数情况下，您所需要的软件均可通过存储库立即获得，而无需查找它们或冒潜在的恶意软件下载风险。</p>
</li>
<li>
<p>新鲜且稳定</p>
<p>Manjaro基于独立开发的Arch操作系统。在Linux社区中，Arch本身以其异常快速，强大且轻量级的发行版而闻名，该发行版可访问最新软件。但是，Arch还针对经验更丰富或技术娴熟的用户。 若最新的软件出现一些问题，例如与现有软件的不兼容性或错误的话，有经验的用户可以自己解决这些问题。但是对于没有足够专业知识的普通用户，或者对于不想弄清楚问题的来龙去脉的用户来说，就比较麻烦。 为防止出现此种问题，Manjaro 向 Arch 存储库添加了额外的测试层。普通软件包将通过这些附加层，并且只会在没有更多问题的情况下才发布给想要稳定系统的用户。</p>
</li>
</ul>
<h3><a class="header" href="#manjaro系统安装" id="manjaro系统安装">manjaro系统安装</a></h3>
<ol>
<li>进入<code>清华镜像</code>网站，查找<code>manjaro</code>关键字，找到<code>manjaro</code>系统安装iso，有三个桌面版本<code>gnome</code>、<code>kde</code>、<code>xfce</code>（有什么区别请网上搜索学习）。</li>
<li>下载manjaro xfce版本。</li>
<li>安装manjaro xfce，如果试用，使用虚拟机体验；如果真机安装，将iso写入到usb中，pc机设置usb启动。</li>
<li>安装过程简单，<code>language=zh_CN</code>，<code>boot with open source</code>，<code>timezone shanghai</code>等，最后一步到93%时会下载一些包，由于官方网络速度慢，先关闭网络（跳过此步骤），然后就会提示安装完成，（虚拟机卸掉加载的iso。真机把usb拔掉）重新启动。</li>
<li>进入安装后的操作系统，打开网络。</li>
</ol>
<h3><a class="header" href="#manjaro系统配置" id="manjaro系统配置">manjaro系统配置</a></h3>
<blockquote>
<p>具体怎么设置，网上搜即可，不复述。</p>
</blockquote>
<ol>
<li>pacman将源改成国内的。</li>
<li>将archlinuxcn配置为ustc（软件较全，速度稳定），<strong>传说中的tsinghua时不时的就没有找到软件、网速时而变得非常慢</strong>。</li>
<li>安装yay。</li>
<li>修改<code>xfce终端</code>，加入参数<code>--drop-down</code>，改为下滑式。快捷键自行定义（例如：F12）。</li>
</ol>
<h3><a class="header" href="#manjaro软件安装" id="manjaro软件安装">manjaro软件安装</a></h3>
<blockquote>
<p>软件具体什么功能，不懂的就搜索一下。软件具体安装过程，去搜索。</p>
</blockquote>
<ul>
<li>
<p>日常软件</p>
<ul>
<li>搜狗输入法、四叶草输入法</li>
<li>Google Chrome</li>
<li>LibreOffice</li>
<li>Typora</li>
<li>kate</li>
</ul>
</li>
<li>
<p>开发IDE</p>
<ul>
<li>IDEA 社区版</li>
<li>Virtual Studio Code</li>
</ul>
</li>
<li>
<p>版本控制</p>
<ul>
<li>GIT</li>
<li>GitAhead</li>
</ul>
</li>
<li>
<p>数据库</p>
<ul>
<li>Navicat、Dbeaver</li>
<li>PostgreSql</li>
<li>redis-desktop-manager</li>
</ul>
</li>
<li>
<p>其它</p>
<ul>
<li>
<p>JDK（OpenJDK、Amazon Corretto ...）</p>
</li>
<li>
<p>Rust</p>
</li>
<li>
<p>Termius</p>
</li>
<li>
<p>FileZilla</p>
</li>
<li>
<p>Docker、Podman</p>
</li>
<li>
<p>SwitchHosts!</p>
</li>
<li>
<p>Postman</p>
</li>
<li>
<p>unrar</p>
</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#manjaro软件安装技巧" id="manjaro软件安装技巧">manjaro软件安装技巧</a></h4>
<blockquote>
<p>一般使用pacman或yay能完成安装，奈何有一些应用没有提供，所以需要加入额外的操作过程。</p>
</blockquote>
<ul>
<li>使用pacman安装🚀🚀🚀🚀🚀</li>
<li>使用yay安装🚀🚀🚀🚀🚀</li>
<li>单独对PKGBUILD文件进行编辑并执行<code>makepkg -si</code>🚀🚀🚀🚀</li>
<li>使用snap安装🚀🚀</li>
<li>使用brew安装🚀🚀</li>
</ul>
<p>mac抓包</p>
<p>#mitmproxy</p>
<blockquote>
<p>使用mitmproxy，免费</p>
</blockquote>
<h3><a class="header" href="#安装运行" id="安装运行">安装&amp;运行</a></h3>
<ol>
<li>
<p>在mac终端执行命令<code>brew install mitmproxy</code>进行安装</p>
</li>
<li>
<p>执行命令<code>mitmdump —version</code>看到如下输出，代表安装成功</p>
<pre><code class="language-shell">Mitmproxy: 4.0.4
Python:    3.7.3
OpenSSL:   OpenSSL 1.0.2r  26 Feb 2019
Platform:  Darwin-18.2.0-x86_64-i386-64bit
</code></pre>
</li>
<li>
<p>执行命令<code>mitmproxy</code>启动，默认端口为8080，如果要自定义端口<code>-p 端口号</code></p>
</li>
<li>
<p>启动完成，在要抓包的设备中设置网关内容</p>
<pre><code class="language-shell">ip: 127.0.0.1 # 改为启动mitmproxy的机器ip
port: 8080 # 默认。如果自定义就改为自定义端口
</code></pre>
</li>
</ol>
<h3><a class="header" href="#可视化页面" id="可视化页面">可视化页面</a></h3>
<blockquote>
<p>可以通过webui直观查看抓包结果</p>
</blockquote>
<ol>
<li>终端执行命令<code>mitmweb</code>，默认端口8081，修改默认端口<code>--web-port 端口号</code></li>
<li>运行成功后，浏览器弹出<code>127.0.0.1:8081</code>网页，<strong>默认的proxy端口为8080</strong></li>
</ol>
<h3><a class="header" href="#https" id="https">https</a></h3>
<blockquote>
<p>抓取https配置方式</p>
</blockquote>
<ol>
<li>首先启动mitmproxy</li>
<li>打开浏览器输入mitm.it，下载证书（在对应的设备上），关于证书的配置在页面有描述</li>
<li>证书配置完成后，重启mitmproxy即可抓取https包</li>
</ol>
<h2><a class="header" href="#macos-catalina显示read-only-file-system的对应方法" id="macos-catalina显示read-only-file-system的对应方法">MacOS (Catalina)：显示Read-only file system的对应方法</a></h2>
<p>在Catalina版的macOS上以root身份登录，发现创建类似/data之类的目录会会提示Read-only file system，这篇文章介绍一下原因和对应方法。</p>
<h3><a class="header" href="#os版本" id="os版本">OS版本</a></h3>
<pre><code class="language-shell">liumiaocn:util liumiao$ sw_vers
ProductName:	Mac OS X
ProductVersion:	10.15.2
BuildVersion:	19C57
liumiaocn:util liumiao$ 
</code></pre>
<h3><a class="header" href="#现象" id="现象">现象</a></h3>
<pre><code class="language-shell">liumiaocn:/ root# id
uid=0(root) gid=0(wheel) groups=0(wheel),1(daemon),2(kmem),3(sys),4(tty),5(operator),8(procview),9(procmod),12(everyone),20(staff),29(certusers),61(localaccounts),80(admin),701(com.apple.sharepoint.group.1),33(_appstore),98(_lpadmin),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh),400(com.apple.access_remote_ae)
liumiaocn:/ root# mkdir -p /data
mkdir: /data: Read-only file system
liumiaocn:/ root# 
</code></pre>
<h3><a class="header" href="#原因" id="原因">原因</a></h3>
<p>根据官方提示，升级至Catalina之后，硬盘会分为两部分：</p>
<ul>
<li>只读部分</li>
<li>可写部分</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200215112038738.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdW1pYW9jbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<blockquote>
<p>With macOS Catalina, you can no longer store files or data in the read-only system volume, nor can you write to the “root” directory ( / ) from the command line, such as with Terminal.</p>
</blockquote>
<p>在Catalina版本，使用者无法在只读系统卷进行数据的存储，使用root在通过命令行的方式也无法对/根目录下进行写操作了。</p>
<p>详细可参看：https://support.apple.com/en-us/HT210650</p>
<h3><a class="header" href="#对应方法" id="对应方法">对应方法</a></h3>
<p>首先设定SIP，详细可参看：https://liumiaocn.blog.csdn.net/article/details/104328486</p>
<pre><code class="language-shell">liumiaocn:~ root# csrutil status
System Integrity Protection status: disabled.
liumiaocn:~ root# mkdir -p /data
mkdir: /data: Read-only file system
liumiaocn:~ root#
</code></pre>
<p>可以看到此时仍然无法创建目录，因为/仍然是只读方式, 修改一下/使之具有write的权限可以看到即可进行操作：</p>
<pre><code class="language-shell">liumiaocn:~ root# mount -uw /
liumiaocn:~ root# mkdir -p /data
liumiaocn:~ root# 
</code></pre>
<h3><a class="header" href="#注意事项" id="注意事项">注意事项</a></h3>
<p>注意此种方式如果重启，mount设定的/的write属性就会失去</p>
<pre><code class="language-shell">liumiaocn:~ root# ls /data
liumiaocn:~ root# mkdir -p /test
mkdir: /test: Read-only file system
liumiaocn:~ root# csrutil status
System Integrity Protection status: disabled.
liumiaocn:~ root# 
</code></pre>
<p>这种情况下可以使用软连接的方式解决这个问题</p>
<pre><code class="language-shell">liumiaocn:/ root# mount -uw /
liumiaocn:/ root# rm -rf /data/
liumiaocn:/ root# mkdir -p /usr/local/data
liumiaocn:/ root# 
</code></pre>
<p>创建软连接</p>
<pre><code class="language-shell">liumiaocn:/ root# ln -s /usr/local/data /data
liumiaocn:/ root# ls -l /data
lrwxr-xr-x  1 root  admin  15 Feb 15 16:32 /data -&gt; /usr/local/data
liumiaocn:/ root#
</code></pre>
<p>这样在重启之后就没有问题了，详细可参看如下日志：</p>
<pre><code class="language-shell">liumiaocn:~ root# mkdir /test
mkdir: /test: Read-only file system
liumiaocn:~ root# cd /data
liumiaocn:data root# mkdir test
liumiaocn:data root# ls
test
liumiaocn:data root# 
</code></pre>
<p>————————————————
版权声明：本文为CSDN博主「liumiaocn」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/liumiaocn/article/details/104324664</p>
<h1><a class="header" href="#macos系统空间占用过大" id="macos系统空间占用过大">macOS系统空间占用过大</a></h1>
<h3><a class="header" href="#开发工具" id="开发工具">开发工具</a></h3>
<h5><a class="header" href="#xcode" id="xcode">Xcode</a></h5>
<blockquote>
<p>核心思想将文件转移到其它空间，再链接到原有目录</p>
</blockquote>
<ol>
<li>执行命令<code>cd /</code></li>
<li>执行命令<code>du -sh *</code>查找哪些目录下有大文件</li>
<li>找到后确认能删除就删除，如果不能删除就使用命令<code>ln -s</code>将大文件迁出系统空间</li>
<li>用iOS举例，最大的文件就是模拟器文件，目录<code>/Library/Developer/CoreSimulator/Profiles/Runtimes</code>，将此目录<code>mv -r</code>到其它空间(如：<code>/Volumn/dev/ios/Runtimes</code>)，移动时间取决于文件大小</li>
<li>这时<code>/Library/Developer/CoreSimulator/Profiles</code>已经为空，使用命令<code>ln -s /Volumn/dev/ios/Runtimes ./</code>生成一个链接文件</li>
<li>启动xcode模拟器，校验是否正常</li>
</ol>
<h5><a class="header" href="#android-studio" id="android-studio">Android Studio</a></h5>
<blockquote>
<p>android将SDK目录和AVD迁移出即可，步骤如上类似</p>
</blockquote>
<h3><a class="header" href="#使用omnidisksweeper免费应用" id="使用omnidisksweeper免费应用">使用OmniDiskSweeper免费应用</a></h3>
<blockquote>
<p>计算所有目录下的文件大小</p>
</blockquote>
<ol>
<li>打开应用，让它计算所有文件夹的大小。</li>
<li>根据文件夹大小，找出最占空间的文件夹。</li>
</ol>
<pre><code>HomeBrew占用较大，主要是.git文件夹巨大，直接删除文件夹内的文件。
Docker应用，docker.raw空间占用巨大，先修改空间大小，再移动此文件到非系统磁盘目录。
</code></pre>
<blockquote>
<p>展示我安装的macOS软件，都是免费，无破解无收费</p>
</blockquote>
<h2><a class="header" href="#文本工具" id="文本工具">文本工具</a></h2>
<ul>
<li><strong>CotEditor</strong>，文本编辑，功能比较强大，免费</li>
<li><strong>Typora</strong>，markdown文本编辑，非常强大，免费可升级</li>
<li><strong>LibreOffice</strong>，word、excel、ppt等文档编辑，免费使用，有增值收费功能</li>
<li><strong>MindLine</strong>，一个封装了百度思维导图的编辑工具，免费</li>
<li><strong>SwitchHosts!</strong>，系统hosts编辑工具，方便开发使用切换hosts，免费</li>
</ul>
<h2><a class="header" href="#文件传输" id="文件传输">文件传输</a></h2>
<ul>
<li><strong>FileZilla</strong>，文件传输，支持ftp、sftp等，免费</li>
<li><strong>Sourcetree</strong>，git客户端，支持github、gitlab，免费</li>
</ul>
<h2><a class="header" href="#数据库管理" id="数据库管理">数据库管理</a></h2>
<ul>
<li><strong>Navicat</strong>，mysql客户端，免费不维护</li>
<li><strong>P3X Redis UI</strong>，redis客户端，免费</li>
</ul>
<h2><a class="header" href="#代码开发" id="代码开发">代码开发</a></h2>
<ul>
<li><strong>Intellij IDEA</strong>，java开发IDE，收费（<em>可使用EAP免费</em>）</li>
<li><strong>CLion</strong>，rust开发IDE，收费（<em>可使用EAP免费</em>）</li>
<li><strong>Android Studio</strong>，android应用开发，免费</li>
<li><strong>Xcode</strong>，iOS应用开发，免费</li>
<li><strong>Visual Studio Code</strong>，文本开发，支持插件安装，免费</li>
</ul>
<p>##SSH工具</p>
<ul>
<li><strong>Termius</strong>，ssh连接工具，免费版无sftp等功能，只有命令行就够用</li>
</ul>
<h2><a class="header" href="#远程api调试工具" id="远程api调试工具">远程api调试工具</a></h2>
<ul>
<li><strong>Postman</strong>，请求调试工具，免费强悍</li>
</ul>
<h2><a class="header" href="#刷新dns缓存" id="刷新dns缓存">刷新DNS缓存</a></h2>
<pre><code class="language-shell">sudo killall -HUP mDNSResponder
sudo killall mDNSResponderHelper
sudo dscacheutil -flushcache
</code></pre>
<blockquote>
<p>Fork是一款免费的git图形客户端，功能强大。由于sourcetree使用的时候需要注册一个账号，一直无法注册，就改使用了Fork，没想到还有意外收获🙂。</p>
</blockquote>
<ol>
<li>点击菜单<code>File - New Tab</code>可以切换不同的仓库。</li>
<li>点击菜单<code>File - Clone…</code>克隆***.git仓库代码。</li>
<li>点击菜单<code>Repository</code>有git最基本常用的操作。</li>
<li>菜单<code>Respository - Git Flow</code>提供git flow流程化操作。</li>
<li>菜单<code>Repository - Git LFS</code>提供大文件处理方式。</li>
<li>主界面左侧有五个栏目</li>
</ol>
<pre><code class="language-javascript">All - 展示所有仓库
Recent - 最近使用的仓库
Bitbucket - Bitbucket登录仓库、展示账户信息
GitHub - GitHub登录仓库、展示账户信息
GitLab - GitLab登录仓库、展示账户信息
</code></pre>
<ol start="7">
<li>主界面All模式，中间展示仓库列表，双击已经clone完成的仓库进入</li>
<li>仓库内</li>
</ol>
<pre><code class="language-javascript">左侧 - 仓库的基本结构，可以用鼠标右键点击执行操作
右侧(上) - git log记录，可以用鼠标右键点击执行操作
右侧(下) - 点击git log记录后，展示响应的信息(Commit当时提交文件，Changes当时提交文件改变内容对比，File Tree当时提交的文件树)
</code></pre>
<ol start="9">
<li>使用pull request</li>
</ol>
<blockquote>
<p>可以发起代码合并申请，让审核代码人进行review</p>
</blockquote>
<pre><code class="language-markdown">仓库内
左侧
1. 展开Remotes
2. 右键点击要发起pull request的分支
3. 点击Create Pull Request on GitHub.com...
4. 在弹出框内点击Send Pull Request
5. OK
</code></pre>
<blockquote>
<p>开发时，当safari地址栏输入<strong>http</strong>://localhost，却跳转到<strong>https</strong>://localhost的问题，百思不得其解。搜索baidu毛都没有。</p>
</blockquote>
<p>解决方案如下：</p>
<ol>
<li>打开safari</li>
<li>快捷键<code>command + ,</code></li>
<li>隐私 -&gt; 管理网站数据</li>
<li>搜索<code>localhost</code></li>
<li>点击<code>移除</code></li>
</ol>
<h4><a class="header" href="#参考" id="参考">参考</a></h4>
<ul>
<li><a href="https://apple.stackexchange.com/questions/215077/safari-redirecting-http-to-non-existent-https">Safari Redirecting http to (non-existent) https</a></li>
</ul>
<h4><a class="header" href="#学习" id="学习">学习</a></h4>
<h2><a class="header" href="#什么是hsts" id="什么是hsts">什么是HSTS？</a></h2>
<h3><a class="header" href="#1-strict-transport-security" id="1-strict-transport-security">1. Strict-Transport-Security</a></h3>
<p><a href="http://tools.ietf.org/html/rfc6797">HTTP Strict Transport Security</a>，简称为HSTS。它允许一个HTTPS网站，要求浏览器总是通过HTTPS来访问它。现阶段，除了Chrome浏览器，Firefox4+，以及Firefox的NoScript扩展都支持这个响应头。</p>
<p>我们知道HTTPS相对于HTTP有更好的安全性，而很多HTTPS网站，也可以通过HTTP来访问。开发人员的失误或者用户主动输入地址，都有可能导致用户以HTTP访问网站，降低了安全性。一般，我们会通过Web Server发送301/302重定向来解决这个问题。现在有了HSTS，可以让浏览器帮你做这个跳转，省一次HTTP请求。</p>
<p>要使用HSTS，只需要在你的<strong>HTTPS</strong>网站响应头中，加入下面这行：</p>
<pre><code class="language-http">strict-transport-security: max-age=16070400; includeSubDomains
</code></pre>
<p>includeSubDomains是可选的，用来指定是否作用于子域名。支持HSTS的浏览器遇到这个响应头，会把当前网站加入HSTS列表，然后在max-age指定的秒数内，当前网站所有请求都会被重定向为https。即使用户主动输入http://或者不输入协议部分，都将重定向到https://地址。</p>
<p>Chrome内置了一个HSTS列表，默认包含Google、Paypal、Twitter、Linode等等服务。我们也可以在Chrome输入chrome://net-internals/#hsts，进入HSTS管理界面。在这个页面，你可以增加/删除/查询HSTS记录。例如，你想一直以https访问某网址，通过“add Domain”加上去就好了。查看Chrome内置的全部HSTS列表，或者想把自己的网站加入这个列表，请<a href="http://www.chromium.org/sts">点这里</a>。</p>
<h3><a class="header" href="#2-x-frame-options" id="2-x-frame-options">2. X-Frame-Options</a></h3>
<p><a href="http://tools.ietf.org/html/draft-ietf-websec-x-frame-options-01">X-Frame-Options</a>，已经转正为<a href="http://tools.ietf.org/html/draft-ietf-websec-frame-options-00">Frame-Options</a>，但现阶段使用最好还是带上X-。Chrome4+、Firefox3.6.9+、IE8+均支持，详细的浏览器支持情况<a href="https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options?redirectlocale=en-US&amp;redirectslug=The_X-FRAME-OPTIONS_response_header#Browser_compatibility">看这里</a>。使用方式如下：</p>
<pre><code class="language-http">x-frame-options: SAMEORIGIN
</code></pre>
<p>这个响应头支持三种配置：</p>
<ul>
<li>DENY：不允许被任何页面嵌入；</li>
<li>SAMEORIGIN：不允许被本域以外的页面嵌入；</li>
<li>ALLOW-FROM uri：不允许被指定的域名以外的页面嵌入（Chrome现阶段不支持）；</li>
</ul>
<p>如果某页面被不被允许的页面以<iframe>或<frame>的形式嵌入，IE会显示类似于“此内容无法在框架中显示”的提示信息，Chrome和Firefox都会在控制台打印信息。由于嵌入的页面不会加载，这就减少了点击劫持（Clickjacking）的发生。</p>
<h3><a class="header" href="#3-x-xss-protection" id="3-x-xss-protection">3. X-XSS-Protection</a></h3>
<p>顾名思义，这个响应头是用来防范XSS的。较早我是在介绍IE8的文章里看到这个，现在主流浏览器都支持，并且默认都开启了XSS保护，用这个header可以关闭它。它有几种配置：</p>
<ul>
<li>0：禁用XSS保护；</li>
<li>1：启用XSS保护；</li>
<li>1; mode=block：启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）；</li>
</ul>
<p>浏览器提供的XSS保护机制并不完美，但是开启后仍然可以提升攻击难度，总之没有特别的理由，不要关闭它。</p>
<h3><a class="header" href="#4-x-content-type-options" id="4-x-content-type-options">4. X-Content-Type-Options</a></h3>
<p>互联网上的资源有各种类型，通常浏览器会根据响应头的Content-Type字段来分辨它们的类型。例如：&quot;text/html&quot;代表html文档，&quot;image/png&quot;是PNG图片，&quot;text/css&quot;是CSS样式文档。然而，有些资源的Content-Type是错的或者未定义。这时，某些浏览器会启用MIME-sniffing来猜测该资源的类型，解析内容并执行。</p>
<p>例如，我们即使给一个html文档指定Content-Type为&quot;text/plain&quot;，在IE8-中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。通过下面这个响应头可以禁用浏览器的类型猜测行为：</p>
<pre><code class="language-http">X-Content-Type-Options: nosniff
</code></pre>
<p>这个响应头的值只能是nosniff，可用于IE8+和Chrome。另外，它还被Chrome用于扩展下载，<a href="https://developer.chrome.com/extensions/hosting.html">见这里</a>。</p>
<h3><a class="header" href="#5-x-content-security-policy" id="5-x-content-security-policy">5. X-Content-Security-Policy</a></h3>
<p>这个响应头主要是用来定义页面可以加载哪些资源，减少XSS的发生。之前单独介绍过，请点击继续浏览：Content Security Policy介绍。</p>
<h3><a class="header" href="#别人怎么用" id="别人怎么用">别人怎么用</a></h3>
<p>最后，我们来看看几个实际案例：</p>
<p>Google+，使用了这几个本文提到的响应头：</p>
<pre><code class="language-http">BASHx-content-type-options: nosniff  x-frame-options: SAMEORIGIN  x-xss-protection: 1; mode=block
</code></pre>
<p>Twitter使用了这些：</p>
<pre><code class="language-http">BASHstrict-transport-security: max-age=631138519  x-frame-options: SAMEORIGIN  x-xss-protection: 1; mode=block
</code></pre>
<p>PayPal的：</p>
<pre><code class="language-http">BASHX-Frame-Options: SAMEORIGIN  Strict-Transport-Security: max-age=14400
</code></pre>
<p>Facebook则使用了这些（配置了详细的CSP，关闭了XSS保护）：</p>
<pre><code class="language-http">BASHstrict-transport-security: max-age=60  x-content-type-options: nosniff  x-frame-options: DENY  x-xss-protection: 0  content-security-policy: default-src *;script-src https://*.facebook.com http://*.facebook.com https://*.fbcdn.net http://*.fbcdn.net *.facebook.net *.google-analytics.com *.virtualearth.net *.google.com 127.0.0.1:* *.spotilocal.com:* chrome-extension://lifbcibllhkdhoafpjfnlhfpfgnpldfl 'unsafe-inline' 'unsafe-eval' https://*.akamaihd.net http://*.akamaihd.net;style-src * 'unsafe-inline';connect-src https://*.facebook.com http://*.facebook.com https://*.fbcdn.net http://*.fbcdn.net *.facebook.net *.spotilocal.com:* https://*.akamaihd.net ws://*.facebook.com:* http://*.akamaihd.net https://fb.scanandcleanlocal.com:*;
</code></pre>
<pre><code class="language-shell">#之前安装过其他版本，可以先全部移除开发工具
sudo rm -rf /Library/Developer/CommandLineTools
#安装
xcode-select --install
#tip:切换版本
sudo xcode-select -switch /Library/Developer/CommandLineTools/
#如果后来你安装了Xcode，可以切回
# Change the path if you installed Xcode somewhere else.
sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
</code></pre>
<h2><a class="header" href="#rust-安装" id="rust-安装">Rust 安装</a></h2>
<h4><a class="header" href="#使用vscode" id="使用vscode">使用vscode</a></h4>
<ol>
<li>安装rust插件</li>
<li>安装rustup</li>
<li>重启vscode，安装rust server</li>
</ol>
<h4><a class="header" href="#debug" id="debug">debug</a></h4>
<p>安装<code>CodeLLDB</code>插件，如果有发生<em>Acquiring CodeLLDB platform package</em>，执行<a href="https://github.com/vadimcn/vscode-lldb/releases/">离线下载</a>对应版本。在扩展里，选择<code>···</code>，选择<code>从VSIX安装</code>，选择下载好的<code>*.vsix</code>文件，安装重启。</p>
<h4><a class="header" href="#问题rustup下载慢" id="问题rustup下载慢">问题：rustup下载慢</a></h4>
<pre><code class="language-shell"># 执行如下两行在命令行中
export RUSTUP_DIST_SERVER=&quot;https://mirrors.ustc.edu.cn/rust-static&quot;
export RUSTUP_UPDATE_ROOT=&quot;https://mirrors.ustc.edu.cn/rust-static/rustup&quot;
</code></pre>
<p>修改后，继续执行安装。</p>
<h2><a class="header" href="#cargo国内源" id="cargo国内源">Cargo国内源</a></h2>
<ul>
<li>清华tuna源</li>
<li>中科大ustc源</li>
</ul>
<pre><code class="language-shell">[source.crates-io]
replace-with = 'tuna'

[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;

[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;
</code></pre>
<h2><a class="header" href="#rust升级" id="rust升级">Rust升级</a></h2>
<h4><a class="header" href="#rustup-update更新慢" id="rustup-update更新慢">rustup update更新慢</a></h4>
<pre><code class="language-shell"># 执行如下命令，该命令只是一段，全部内容去清华mirror的rust页面中查看
vi ~/.bash_profile
export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup rustup install stable
</code></pre>
<p>或者</p>
<pre><code class="language-shell">vi ~/.bash_profile
export RUSTUP_DIST_SERVER=http://mirrors.rustcc.cn
export RUSTUP_UPDATE_ROOT=http://mirrors.rustcc.cn/rustup rustup install stable
</code></pre>
<p>或者</p>
<pre><code class="language-shell">vi ~/.bash_profile
export RUSTUP_UPDATE_ROOT=http://mirrors.ustc.edu.cn/rust-static/rustup
export RUSTUP_DIST_SERVER=http://mirrors.ustc.edu.cn/rust-static
</code></pre>
<p><code>source ~/.bash_profile</code>再次执行更新即可。</p>
<h2><a class="header" href="#rust交叉编译" id="rust交叉编译">Rust交叉编译</a></h2>
<p>开发在Mac，产品最后运行在Linux。两种环境编译的二进制包是无法在彼此环境上运行的。</p>
<h4><a class="header" href="#macos编译linux运行" id="macos编译linux运行">macOS编译，linux运行</a></h4>
<pre><code class="language-shell">x# 查看可用的目标环境rustup target list# 引入linux静态编译包rustup target add x86_64-unknown-linux-musl# 执行编译	cargo build --release --target=x86_64-unknown-linux-muslFinished release [optimized] target(s) in 54.64s####################################################### 说明编译成功！！！# 在target/x86_64-unknown-linux-musl/release目录内获得。######################################################shell
</code></pre>
<h4><a class="header" href="#编译过程中发生错误" id="编译过程中发生错误">编译过程中发生错误</a></h4>
<h5><a class="header" href="#提示binsh-musl-gcc-command-not-found" id="提示binsh-musl-gcc-command-not-found">提示：/bin/sh: musl-gcc: command not found</a></h5>
<pre><code class="language-shell"># 安装
brew install filosottile/musl-cross/musl-cross

# 编辑cargo
vi $HOME/.cargo/config
# 加入如下内容，保存
[target.x86_64-unknown-linux-musl]
linker = &quot;x86_64-linux-musl-gcc&quot;

# 执行目标linux平台的编译命令
# 如果提示OPENSSL_DIR unset，但是环境变量一直都可用，解决方案是把OPENSSL_DIR=&quot;/usr/local/opt/openssl@1.1&quot; 加入到命令前面
CC_x86_64_unknown_linux_musl=&quot;x86_64-linux-musl-gcc&quot; cargo build --release --target=x86_64-unknown-linux-musl
</code></pre>
<h5><a class="header" href="#提示openssl-err的错误" id="提示openssl-err的错误">提示：openssl err的错误</a></h5>
<pre><code class="language-shell"># 安装openssl 1.1
brew install openssl@1.1

# 修改环境变量
vi ~/.bash_profile
export OPENSSL_DIR=&quot;/usr/local/opt/openssl@1.1&quot; # 根据实际目录填写，这是brew默认安装目录
# 保存退出

# 执行source完成
source ~/.bash_profile
</code></pre>
<h5><a class="header" href="#提示ring-xxxxx编译问题没有找到文件或目录" id="提示ring-xxxxx编译问题没有找到文件或目录">提示ring-x.xx.xx编译问题，没有找到文件或目录</a></h5>
<pre><code class="language-shell"># 切换为清华源tuna
[source.crates-io]
replace-with = 'tuna'

[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;
</code></pre>
<p>参考：<a href="https://www.qttc.net/529-rust-cross-compile-mac-to-linux.html">https://www.qttc.net/529-rust-cross-compile-mac-to-linux.html</a></p>
<p>参考：<a href="https://blog.csdn.net/u013195275/article/details/106070326/">https://blog.csdn.net/u013195275/article/details/106070326/</a></p>
<h2><a class="header" href="#rust语法" id="rust语法">Rust语法</a></h2>
<h3><a class="header" href="#1-rust目录" id="1-rust目录">1. Rust目录</a></h3>
<h4><a class="header" href="#11-平级目录" id="11-平级目录">1.1 平级目录</a></h4>
<ul>
<li>src
<ul>
<li>main.rs</li>
<li>api.rs</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">// main.rs
mod api; // 平级引入api.rs 

fn main() {
  api::hello();
}
</code></pre></pre>
<h4><a class="header" href="#12-非平级目录" id="12-非平级目录">1.2 非平级目录</a></h4>
<ul>
<li>src
<ul>
<li>main.rs</li>
<li>api
<ul>
<li>mod.rs</li>
<li>api.rs</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// mod.rs
mod api; // 引入api.rs，注意作用域pub
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.rs
mod api; // 引入api包，注意作用域pub，rust自动查找目录下的mod.rs、lib.rs等
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#13-任意目录" id="13-任意目录">1.3 任意目录</a></h4>
<pre><pre class="playground"><code class="language-rust">use crate::api::api::hello;

fn main() {
  hello();
}
</code></pre></pre>
<h3><a class="header" href="#2-actix-web使用" id="2-actix-web使用">2. actix-web使用</a></h3>
<h4><a class="header" href="#21-http的postgetdeleteput" id="21-http的postgetdeleteput">2.1 http的post\get\delete\put</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get method
// path
#[get(&quot;/advs/{id}&quot;)]
pub async fn detail(_id: web::Path&lt;u32&gt;) -&gt; Result&lt;HttpResponse, Error&gt; {
    Ok(HttpResponse::Ok().body(format!(&quot;hello id:{}&quot;, _id)))
}
// query
#[get(&quot;/advs&quot;)]
pub async fn list(page: web::Query&lt;Page&gt;) -&gt; Result&lt;HttpResponse, Error&gt; {
    Ok(HttpResponse::Ok().body(format!(&quot;hello page:{}&quot;, &amp;page)))
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// post method
// form
#[post(&quot;/advs&quot;)]
pub async fn add(page: web::Form&lt;Page&gt;) -&gt; Result&lt;HttpResponse, Error&gt; {
    Ok(HttpResponse::Ok().body(format!(&quot;hello page:{}&quot;, &amp;page)))
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#3-sqlx时间datetimeutc问题解决方式" id="3-sqlx时间datetimeutc问题解决方式">3. sqlx时间DateTime<Utc>问题解决方式</a></h3>
<p><em>这个问题sqlx还没有解决方案，只能从业务代码中转换。</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用FixedOffset将时区变为+08:00
let created_at: NaiveDateTime = row.get(&quot;created_at&quot;);
let updated_at: NaiveDateTime = row.get(&quot;updated_at&quot;);
let tz_offset = FixedOffset::east(8 * 3600);
let created_at: DateTime&lt;FixedOffset&gt; = tz_offset.from_local_datetime(&amp;created_at).unwrap();
let updated_at: DateTime&lt;FixedOffset&gt; = tz_offset.from_local_datetime(&amp;updated_at).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p><strong>或</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ct: DateTime&lt;Utc&gt; = row.get(&quot;create_time&quot;);
ct.with_timezone(&amp;FixedOffset::east(8*3600));
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#4-如何运行没有cargotoml的examplesxxxrs文件" id="4-如何运行没有cargotoml的examplesxxxrs文件">4. 如何运行没有cargo.toml的examples/xxx.rs文件</a></h3>
<pre><code class="language-shell"># 项目根目录下执行
# 例如：warp
cargo run --example xxx
</code></pre>
<blockquote>
<p>git平台有多个的时候，sshkeys使用同一个不是很安全</p>
</blockquote>
<h3><a class="header" href="#多sshkeys设置" id="多sshkeys设置">多Sshkeys设置</a></h3>
<ol>
<li>生成gitlab sshkeys</li>
</ol>
<pre><code class="language-shell">ssh-keygen -t rsa -C &quot;你的邮箱&quot; -f ~/.ssh/id_rsa_gitlab

# 一路回车
</code></pre>
<ol start="2">
<li>生成github sshkeys</li>
</ol>
<pre><code class="language-shell">ssh-keygen -t rsa -C &quot;你的邮箱&quot; -f ~/.ssh/id_rsa_github

# 一路回车
</code></pre>
<ol start="3">
<li>进入<code>.ssh</code>目录</li>
</ol>
<pre><code class="language-shell">cd ~/.ssh

# 目录内会有四个文件
id_rsa_gitlab id_rsa_gitlab.pub id_rsa_github id_rsa_github.pub
</code></pre>
<ol start="4">
<li>执行agent</li>
</ol>
<pre><code class="language-shell">ssh-agent -s 
</code></pre>
<ol start="5">
<li>添加私钥</li>
</ol>
<pre><code class="language-shell">ssh-add id_rsa_gitlab
ssh-add id_rsa_github

# 添加成功，提示Identity added: ./id_rsa_xxxx (xxxx@xxx.com)
</code></pre>
<ol start="6">
<li>查看是否添加成功</li>
</ol>
<pre><code class="language-shell">ssh-add -l

# 会有两条内容，代表成功添加
</code></pre>
<ol start="7">
<li>修改~/.ssh/config文件，没有就创建</li>
</ol>
<pre><code class="language-shell"># gitlab
Host gitlab.com
HostName gitlab.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_gitlab

# github
Host github.com
HostName github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_github
</code></pre>
<ol start="8">
<li>
<p>将对应的id_rsa_xxxx.pub内容添加到xxxx.com的Ssh keys设置中</p>
</li>
<li>
<p>验证设置是否准确</p>
</li>
</ol>
<pre><code class="language-shell"># 检查github
ssh -T git@github.com 
# 成功提示
# Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 

# 检查gitlab
ssh -T git@gitlab.com 
# 成功提示
# Welcome to GitLab, @xxx! 
</code></pre>
<p>现在就可以使用ssh进行git clone了~~</p>
<h3><a class="header" href="#可能会用到的命令" id="可能会用到的命令">可能会用到的命令</a></h3>
<pre><code class="language-shell"># 删除所有已经添加的id_rsa_xxxx
ssh-add -D
</code></pre>
<h3><a class="header" href="#参考文献" id="参考文献">参考文献</a></h3>
<ul>
<li>
<p><a href="https://www.cnblogs.com/godfeer/p/12214301.html">Git高级之配置多个SSH key</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/p/7d57ce4147d3">解决git@github.com: Permission denied (publickey). Could not read from remote repository.</a></p>
</li>
</ul>
<h2><a class="header" href="#解决github的rawgithubusercontentcom无法连接问题" id="解决github的rawgithubusercontentcom无法连接问题">解决GitHub的raw.githubusercontent.com无法连接问题</a></h2>
<ol>
<li>访问https://site.ip138.com/raw.githubusercontent.com/</li>
<li>输入raw.githubusercontent.com</li>
<li>复制一个地理位置近的ip</li>
<li>粘贴到hosts中，例如：<code>151.101.76.133 raw.githubusercontent.com</code></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
