<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>技术知识wiki</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="way-api-wiki/基础支持/⭐️总结，先读此文.html"><strong aria-hidden="true">1.</strong> 先读此文</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Web服务器</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/WEB服务器/nginx使用ssl.html"><strong aria-hidden="true">2.1.</strong> Nginx使用SSL</a></li><li class="chapter-item expanded "><a href="way-api-wiki/WEB服务器/nginx本地开发加入ssl.html"><strong aria-hidden="true">2.2.</strong> Nginx本地开发加入SSL</a></li><li class="chapter-item expanded "><a href="way-api-wiki/WEB服务器/Tengine开启http2.html"><strong aria-hidden="true">2.3.</strong> Tengine开启http2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 服务器OS</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/服务器OS/linux基础.html"><strong aria-hidden="true">3.1.</strong> Linux基础</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Alpine Linux</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/服务器OS/alpine/docker-rust镜像使用帮助.html"><strong aria-hidden="true">3.2.1.</strong> Docker Rust镜像使用帮助</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> CentOS</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/服务器OS/CentOS/CentOS7常见问题解决.html"><strong aria-hidden="true">3.3.1.</strong> CentOS7常见问题解决</a></li><li class="chapter-item expanded "><a href="way-api-wiki/服务器OS/CentOS/CentOS7日常操作命令.html"><strong aria-hidden="true">3.3.2.</strong> CentOS7日常操作命令</a></li><li class="chapter-item expanded "><a href="way-api-wiki/服务器OS/CentOS/CentOS7挖矿病毒清理.html"><strong aria-hidden="true">3.3.3.</strong> CentOS7挖矿病毒清理</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 桌面OS</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Manjaro</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/manjaro.html"><strong aria-hidden="true">4.1.1.</strong> Manjaro基本使用</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> MacOS</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS抓包.html"><strong aria-hidden="true">4.2.1.</strong> macOS抓包</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS显示Read-only file system的对应方法.html"><strong aria-hidden="true">4.2.2.</strong> macOS显示Read-only file system的对应方法</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS系统空间占用过大.html"><strong aria-hidden="true">4.2.3.</strong> macOS系统空间占用过大</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS我的软件.html"><strong aria-hidden="true">4.2.4.</strong> macOS我的软件</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS刷新DNS缓存.html"><strong aria-hidden="true">4.2.5.</strong> macOS刷新DNS缓存</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS使用fork的基本功能（git图形客户端）.html"><strong aria-hidden="true">4.2.6.</strong> macOS使用fork的基本功能（git图形客户端）</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS浏览器safari请求http跳转到https.html"><strong aria-hidden="true">4.2.7.</strong> macOS浏览器safari请求http跳转到https</a></li><li class="chapter-item expanded "><a href="way-api-wiki/桌面OS/macOS不安装XCode使用CLion开发.html"><strong aria-hidden="true">4.2.8.</strong> macOS不安装XCode使用CLion开发</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 开发语言</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/Rust/Rust安装.html"><strong aria-hidden="true">5.1.1.</strong> Rust 安装</a></li><li class="chapter-item expanded "><a href="way-api-wiki/Rust/Rust常用语法总结.html"><strong aria-hidden="true">5.1.2.</strong> Rust常用语法总结</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Git</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="way-api-wiki/Git/GIT多Sshkeys管理.html"><strong aria-hidden="true">6.1.</strong> Git多ssh keys管理</a></li><li class="chapter-item expanded "><a href="way-api-wiki/Git/github相关链接访问慢、失效问题.html"><strong aria-hidden="true">6.2.</strong> github相关链接访问慢、失效问题</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">技术知识wiki</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p>基础支持是为了保障运行，方便工作。
以下软件，本地部署一律使用docker。</p>
</blockquote>
<h2><a class="header" href="#内部支持" id="内部支持">内部支持</a></h2>
<table><thead><tr><th>内部支持</th><th>软件</th><th>描述</th><th>替代软件</th></tr></thead><tbody>
<tr><td>内部管理</td><td>钉钉</td><td>提供人员管理、打卡、年假等等各种常备的OA功能。</td><td><a href="https://github.com/o2oa/o2oa">O2OA</a></td></tr>
<tr><td>内部沟通</td><td>钉钉</td><td>提供消息交流、群功能。至于能不能被监控，出于安全考虑，最好独立部署</td><td><a href="https://gitlab.com/superxzl/way-api/wikis/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81/rocket.chat">rocket.chat</a></td></tr>
<tr><td>邮件管理</td><td>钉钉</td><td>内置免费50人的邮件功能，但出于安全考虑，最好单独部署邮件服务器。</td><td><a href="https://gitlab.com/superxzl/way-api/wikis/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81/mailserver">mailserver</a></td></tr>
<tr><td>操作系统</td><td><a href="https://manjaro.org">Manjaro</a></td><td>Manjaro是一个基于Arch Linux的开源发行版本。该软件继承了所有当前高端前沿软件的优点：不仅启动速度快，而且自动化程度高、人工干预少，但能在需要的时候提供必要的帮助。</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#开发语言" id="开发语言">开发语言</a></h2>
<table><thead><tr><th>语言</th><th>描述</th><th>使用场景</th></tr></thead><tbody>
<tr><td>java8</td><td>Java reduces costs, shortens developer timeframes, drives innovation, and improves application services as the programming language of choice for enterprise architecture, finance, and HR. Java is used in many industries including manufacturing, automotive, insurance, and public sector.</td><td>企业业务等</td></tr>
<tr><td>GoLang</td><td>Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.</td><td>高并发、基础框架等，如k8s/docker</td></tr>
<tr><td>Rust</td><td>Empowering everyone to build reliable and efficient software.</td><td>底层技术，计算等</td></tr>
<tr><td>TypeScript</td><td><em>TypeScript</em> brings you optional static type-checking along with the latest ECMAScript features.</td><td>前端开发</td></tr>
</tbody></table>
<h2><a class="header" href="#开发支持" id="开发支持">开发支持</a></h2>
<table><thead><tr><th>开发支持</th><th>软件</th><th>描述</th><th>替代软件</th></tr></thead><tbody>
<tr><td>JDK</td><td>Amazon Corretto 8</td><td>Oracle JDK的后续补丁更新需要收费。Amazon的云业务实际排名第一，jdk的使用量也非常多，支持免费维护是最佳的选择。</td><td><a href="http://openjdk.java.net">OpenJDK</a></td></tr>
<tr><td>代码管理</td><td>gitlab-ee</td><td>gitlab的企业版本，功能强大，本地部署。</td><td><a href="https://github.com/gogs/gogs">gogs</a>，gitea</td></tr>
<tr><td>开发协作</td><td>Confluence</td><td>多人文档协作，有大量的插件资源，可以与钉钉进行关联</td><td><a href="https://github.com/Requarks/wiki">wiki.js</a></td></tr>
<tr><td>知识管理</td><td><a href="https://github.com/Requarks/wiki">wiki.js</a></td><td>这是一个简单实用的wiki</td><td></td></tr>
<tr><td>开发管理</td><td>Jira</td><td>项目管理，有大量插件资源，可以与钉钉进行关联</td><td></td></tr>
<tr><td>数据库</td><td>PostgreSQL</td><td>数据库管理系统</td><td>MySQL8</td></tr>
<tr><td>开发框架</td><td>SpringBoot2</td><td>java开发框架</td><td>其中tomcat可替换为undertow</td></tr>
<tr><td>私服仓库</td><td>Sonatype Nexus</td><td>maven仓库，jar包管理，npm、rpm等。也可以作为docker私服，暂时不做。</td><td></td></tr>
<tr><td>docker私服</td><td>Harbor</td><td>docker images都将存储于此</td><td></td></tr>
<tr><td>SQL审核平台</td><td><a href="https://github.com/hhyo/Archery">Archery</a></td><td>SQL审核执行平台，redis</td><td><a href="https://github.com/cookieY/Yearning-go">Yearning-go</a></td></tr>
<tr><td>全链路监测</td><td>SkyWalking / PinPoint</td><td>监测线上运行程序执行顺序、时间、效率等。（<strong>注：两个开源应用各有各的特点，需要使用时再看当时版本的最新特性对比</strong>）</td><td></td></tr>
<tr><td>ServerLess</td><td>OpenFaas</td><td>无服务函数。可以将一小段代码部署在服务上，web程序可以直接调用。</td><td></td></tr>
<tr><td>CI/CD</td><td>gitlab CI</td><td>持续集成、持续交付（部署）。<strong>如果gitlab CI受限于性能，可使用别的开源产品</strong></td><td>Drone Jenkins Tekton Concourse GoCD</td></tr>
<tr><td>代码审查</td><td>gitlab merge request</td><td>gitlab中自带的代码请求合并功能</td><td>gerrit</td></tr>
<tr><td><del>MySQL数据同步</del></td><td><del><a href="https://github.com/zendesk/maxwell">Maxwell</a></del></td><td><del>读取mysql的binlog，将行更新数据作为json发布到kafka、redis等生产工具，待订阅者对数据进行消费。</del></td><td>debezium优先。 <del>canal</del>（<del>不会使用的，只做展示，除非有重大变革</del>）</td></tr>
<tr><td>变动数据捕捉（CDC）</td><td><a href="https://github.com/debezium/debezium">debezium</a></td><td>Debezium是一个开源项目，它为变更数据捕获（CDC）提供了一个低延迟的数据流平台。您可以设置和配置Debezium来监视数据库，然后应用程序为数据库的每一行级更改使用事件。只有提交的更改才可见，因此应用程序不必担心事务或回滚的更改。Debezium提供了所有变更事件的单一模型，因此您的应用程序不必担心每种数据库管理系统的复杂性。此外，由于Debezium将数据更改的历史记录在持久的复制日志中，因此您的应用程序可以随时停止和重新启动，并且它将能够使用未运行时丢失的所有事件，从而确保所有事件都得到正确和完全的处理。 <em>PostgreSQL和MySQL都支持</em></td><td></td></tr>
<tr><td>前端服务器</td><td>deno</td><td>deno是一个基于v8、rust和Tokio的Javascript/Typescript的安全运行时。它在内部嵌入了一个typescript的编译器。可以将typescript编译成js然后运行在v8上，并通过c++ libdeno实现js与rust的通信交互，当然deno也可以直接运行Javascript代码。</td><td>nodejs（可互换）</td></tr>
</tbody></table>
<h2><a class="header" href="#运维服务" id="运维服务">运维服务</a></h2>
<table><thead><tr><th>运维服务</th><th>软件</th><th>描述</th><th align="left">替代软件</th></tr></thead><tbody>
<tr><td>基础服务器OS</td><td>Ubuntu Server</td><td>Ubuntu的服务器版本</td><td align="left">Rocky Linux</td></tr>
<tr><td>docker镜像OS</td><td>Alpine</td><td>最安全、体积极小的linux版本</td><td align="left"></td></tr>
<tr><td>CMDB资产管理</td><td></td><td></td><td align="left"></td></tr>
<tr><td>堡垒机</td><td>Teleport</td><td>Teleport是一款简单易用的<strong>开源堡垒机系统</strong>，具有小巧、易用的特点，支持 RDP/SSH/SFTP/Telnet 协议的远程连接和审计管理。</td><td align="left"></td></tr>
<tr><td>运维平台</td><td><a href="https://www.ansible.com">ansible</a></td><td>运维管理平台，可视化管理ansible tower</td><td align="left"><a href="https://www.saltstack.com/">Salt Stack</a></td></tr>
<tr><td>编排部署</td><td>k8s &amp; docker</td><td>服务器部署，产品、stag和开发都统一使用。rancher或kubesphere管理k8s</td><td align="left"></td></tr>
<tr><td>容器管理</td><td>podman</td><td>Podman是一个无守护进程容器引擎，用于在Linux系统上开发、管理和运行OCI容器。容器可以作为root运行，也可以以无root模式运行。简单地说：alias docker=podman。</td><td align="left">docker</td></tr>
<tr><td>容器http服务器</td><td>Traefik</td><td>Træfɪk 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具。</td><td align="left"></td></tr>
<tr><td>http服务器</td><td>nginx</td><td><em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP/POP3/SMTP<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1/100571">服务</a>。</td><td align="left">caddy</td></tr>
<tr><td>分布式文件系统</td><td><a href="https://github.com/sjqzhang/go-fastdfs">go-fastdfs</a></td><td>go-fastdfs 是一个简单的分布式文件系统(私有云存储)，具有无中心、高性能，高可靠，免维护等优点，支持断点续传，分块上传，小文件合并，自动同步，自动修复。</td><td align="left">GlusterFS</td></tr>
<tr><td>配置存储</td><td>etcd</td><td>etcd是用于共享配置和服务发现的分布式，一致性的KV存储系统。</td><td align="left">consul</td></tr>
<tr><td>OSS</td><td>MinIO</td><td>MinIO 是一个基于Apache License v2.0开源协议的对象存储服务。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。</td><td align="left">ceph</td></tr>
<tr><td>MQ</td><td>Pulsar</td><td>Apache Pulsar是一个开源的分布式pub-sub消息传递系统，最初创建于Yahoo，现在是Apache软件基金会的一部分</td><td align="left">Kafka</td></tr>
<tr><td>定时任务</td><td>xxl-job</td><td>一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。</td><td align="left"><a href="https://github.com/PowerJob/PowerJob">PowerJob</a></td></tr>
<tr><td>全文搜索</td><td>ElasticSearch</td><td>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。</td><td align="left"><a href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a>（<strong>刚刚起步不久</strong>）<br><a href="https://github.com/valeriansaliou/sonic">Sonic</a></td></tr>
<tr><td>日志搜集</td><td>ELK</td><td>“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。</td><td align="left"><a href="https://github.com/grafana/loki">Loki</a>，可直接替换</td></tr>
<tr><td>服务网格Service      Mesh</td><td>linkerd2</td><td>Linkerd2 （曾命名为 <a href="https://conduit.io/">Conduit</a>） 是 Buoyant 公司推出的下一代轻量级服务网格框架，开源在 https://github.com/linkerd/linkerd2。与 linkerd 不同的是，它专用于 Kubernetes 集群中，并且比 linkerd 更轻量级（基于 Rust 和 Go，没有了 JVM 等大内存的开销），可以以 sidecar 的方式把代理服务跟实际服务的 Pod 运行在一起（这点跟 Istio 类似）。Linkerd2 的主要特性包括：<br>· 轻量级，速度快，每个代理容器仅占用 10mb RSS，并且额外延迟只有亚毫妙级<br>· 安全，基于 Rust，默认开启 TLS<br>· 端到端可视化<br>· 增强 Kubernetes 的可靠性、可视性以及安全性</td><td align="left">istio，都可互换</td></tr>
<tr><td>机密管理</td><td>Vault</td><td>用于机密管理、加密即服务和特权访问管理的工具</td><td align="left"></td></tr>
<tr><td>云平台</td><td>OpenNebula</td><td>OpenNebula是一个功能强大但易于使用的开源平台，用于构建和管理企业云。 OpenNebula提供了对IT基础架构和应用程序的统一管理，避免了供应商锁定并降低了复杂性，资源消耗和运营成本。</td><td align="left"></td></tr>
</tbody></table>
<h2><a class="header" href="#额外支持" id="额外支持">额外支持</a></h2>
<table><thead><tr><th align="left">名称</th><th>软件</th><th>描述</th><th>替代软件</th></tr></thead><tbody>
<tr><td align="left">博客</td><td>Jekyll</td><td>将纯文本转换为静态博客网站</td><td>Hexo、Zola</td></tr>
<tr><td align="left">BI</td><td>Metabase</td><td>一个简单、开源的方式,通过给公司成员提问,从得到的数据中进行分析、学习。</td><td></td></tr>
<tr><td align="left">文档</td><td>mdBook</td><td>根据markdown创建文档，生成html文件。跟gitbook相似，是用Rust实现。</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#nginx使用ssl" id="nginx使用ssl">nginx使用ssl</a></h2>
<h3><a class="header" href="#使用certbot-auto配置ssl" id="使用certbot-auto配置ssl">使用certbot-auto配置ssl</a></h3>
<h4><a class="header" href="#首次生成证书" id="首次生成证书">首次生成证书</a></h4>
<p>使用免费的Let's encrypt获取证书并让nginx使用，具体如下</p>
<ol>
<li>
<p>安装certbot-auto</p>
<pre><code class="language-shell">wget https://dl.eff.org/certbot-auto
chmod a+x ./certbot-auto
./certbot-auto --help
</code></pre>
</li>
<li>
<p>生成证书</p>
<pre><code class="language-shell">sudo ./certbot-auto certonly --preferred-challenges dns --manual --email geniusmickymouse@qq.com --server https://acme-v02.api.letsencrypt.org/directory -d jicu.vip -d *.jicu.vip
</code></pre>
<p>生成证书过程中需要对指定的域名添加DNS解析信息（一共两条）</p>
<pre><code>_acme-challenge TXT 默认 记录值（填入一长串字母加数字）
</code></pre>
<p>添加DNS完成后，再继续，直到提示完成。</p>
</li>
</ol>
<hr />
<h4><a class="header" href="#nginx配置证书" id="nginx配置证书">nginx配置证书</a></h4>
<ol>
<li>在nginx的conf文件夹中，创建文件<code>ssl.conf</code></li>
</ol>
<pre><code class="language-nginx">ssl_certificate       /etc/letsencrypt/live/jicu.vip/fullchain.pem;
ssl_certificate_key   /etc/letsencrypt/live/jicu.vip/privkey.pem;
</code></pre>
<p>将<code>ssl.conf</code>引入到其它域名配置文件www.conf中</p>
<pre><code class="language-nginx">server{
  listen       80;
  server_name  www.jicu.vip;
  return       301 https://$server_name$request_uri;
}
server {
	listen 443 ssl;
	server_name www.jicu.vip;
	include /usr/local/nginx/conf/ssl.conf;
	location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$ {
		root            /apps/web/assets;
		expires         30d;
  }

	location / {
		root   /apps/web/www;
		index  index.html index.htm;
		expires 30d;
  }
}
</code></pre>
<p>检查<code>nginx -t</code>配置是否准确，然后重启<code>nginx -s reload</code>。==检查服务器443端口是否开启。==</p>
<ol start="3">
<li>访问域名www.jicu.vip是否正常，如果不正常问问百度。</li>
</ol>
<h4><a class="header" href="#配置域名自动续期" id="配置域名自动续期">配置域名自动续期</a></h4>
<ol>
<li>
<p>先配置两个环境变量，最好写在/etc/profile，或者.bashrc里面，然后执行source生效</p>
<pre><code class="language-shell"># 阿里云的access key和secret,这个可以是ram子账户授权
export CERTBOT_ALI_KEY=&quot;&quot;
export CERTBOT_ALI_SECRET=&quot;&quot;
</code></pre>
</li>
<li>
<p>下载certbot-alidns放到/usr/bin/，并改名为<code>certbot-alidns</code></p>
<pre><code>编译好的下载，Linux版本,其他版本请自行编译；
链接: https://pan.baidu.com/s/1zk3iM-KTbJr941frtFYJkw 提取码: uxe5
</code></pre>
</li>
<li>
<p>加入定时任务重新生成证书，先编辑一个运行脚本<code>cert-renew.sh</code></p>
<pre><code class="language-bash">#!/bin/bash
# 停止nginx
#nginx -s stop

# 续签
sudo /apps/software/certbot-auto renew --force-renew --cert-name jicu.vip --manual-auth-hook /usr/bin/certbot-alidns &amp;&amp; /usr/local/nginx/sbin/nginx -s reload

# 重启nginx
#nginx -s reload
</code></pre>
<p>写入定时任务</p>
<pre><code class="language-shell"># 编辑定时任务
crontab -e

# 写入定时任务。每周日，凌晨3点执行重新生成证书脚本
* 3 * * 0 /apps/script/cert-renew.sh &gt;&gt; /apps/log/crontab/cert-renew-$(date +&quot;\%Y-\%m-\%d&quot;).log 2&gt;&amp;1

# 查看定时任务列表
crontab -l
</code></pre>
</li>
<li>
<p>手动重新生成证书，==如果有紧急情况==</p>
<pre><code class="language-shell">sudo /apps/software/certbot-auto renew --force-renew --cert-name jicu.vip --manual-auth-hook /usr/bin/certbot-alidns &amp;&amp; /usr/local/nginx/sbin/nginx -s reload
</code></pre>
</li>
<li>
<p>访问http://s.tool.chinaz.com/https/检查<code>SSL</code>过期时间是否更新</p>
</li>
</ol>
<h3><a class="header" href="#使用acmesh配置ssl" id="使用acmesh配置ssl">使用acme.sh配置ssl</a></h3>
<ol>
<li>
<p>安装。查看<a href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E">官方说明</a>。<em>如果是第一次使用，最好阅读一遍</em></p>
</li>
<li>
<p>安装完成后，重启一个命令行窗口<code>alias acme.sh</code>才起作用。</p>
</li>
<li>
<p>配置对应域名运营商的api key。不知道如何配置，查看<a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">官方说明dnsapi</a></p>
</li>
<li>
<p>申请证书。执行命令<code>acme.sh --issue --dns dns_ali -d jicu.vip -d *.jicu.vip</code>。</p>
<ul>
<li>泛域名必须使用<code>--dns</code>来申请，否则会提示<code>The supported validation types are dns-01,but you specified http-01</code>，不同的服务提供商参数值会不同，这里是<code>dns_ali</code>阿里的。</li>
<li>如果出现错误并看不到信息，在命令后面加入<code>--log</code>、<code>--debug</code>或<code>--debug 2</code>，后一个比前一个日志详细度更高。</li>
</ul>
</li>
<li>
<p>安装证书。执行命令<code>acme.sh --install-cert -d jicu.vip \ --key-file       /etc/letsencrypt/live/jicu.vip/privkey.pem  \ --fullchain-file /etc/letsencrypt/live/jicu.vip/fullchain.pem \ --reloadcmd     &quot;/usr/local/nginx/sbin/nginx -s reload&quot;</code></p>
</li>
<li>
<p>打开浏览器查看自己的域名证书是否正常。</p>
</li>
<li>
<p>由于let's encrypt会不定时修改策略，acme.sh也会进行跟进更新，为了防止再次使用acme.sh发生未知问题，使用之前最好进行升级，执行命令<code>acme.sh --upgrade</code></p>
</li>
</ol>
<p>提示：打开<code>https://crt.sh</code>，可以查看证书<strong>申请次数</strong>和<strong>起止时间</strong>是否==正常==。</p>
<h2><a class="header" href="#nginx本地开发加入ssl" id="nginx本地开发加入ssl">nginx本地开发加入ssl</a></h2>
<ol>
<li>
<p>安装<code>openssl</code></p>
</li>
<li>
<p>执行命令</p>
</li>
</ol>
<pre><code class="language-shell"># 用openssl生成key和crt文件
&gt; openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /apps/cert/nginx.key -out /apps/cert/nginx.crt
</code></pre>
<ol start="3">
<li>填写注册内容</li>
</ol>
<pre><code class="language-shell">Country Name (2 letter code) [XX]: CN
State or Province Name (full name) []: beijing    
Locality Name (eg, city) [Default City]: beijing
Organization Name (eg, company) [Default Company Ltd]: 回车
Organizational Unit Name (eg, section) []: 回车
Common Name (eg, your name or your server's hostname) []: *.jicu.vip
Email Address []: geniusmickymouse@qq.com
</code></pre>
<p>注：hostname使用**<code>*.jicu.vip</code><strong>代表泛域名。也可以使用</strong>localhost**。</p>
<ol start="4">
<li>配置nginx</li>
</ol>
<pre><code class="language-nginx">server {
  listen 443 ssl;
  server_name  mp.jicu.vip;

  ssl_certificate /apps/cert/nginx.crt;
  ssl_certificate_key /apps/cert/nginx.key;

  location / {
    root /apps/web/mp;
    index index.html;
  }
}
</code></pre>
<ol start="5">
<li>校验nginx配置，重启</li>
</ol>
<pre><code class="language-shell"># 校验
&gt; nginx -t
nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok
nginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful

# 重启
&gt; nginx -s reload
</code></pre>
<ol start="6">
<li>浏览器访问<code>https://mp.jicu.vip</code>，会有提示（不同浏览器不同），继续（强制）访问。</li>
<li>如果代码中调用<code>https://api.jicu.vip</code>等其它的服务，需要按照==步骤6==在浏览器地址栏中访问一次。</li>
</ol>
<p>本文结束！</p>
<h2><a class="header" href="#为什么要用http2" id="为什么要用http2">为什么要用Http2</a></h2>
<p>提升性能。自行baidu获取答案。</p>
<h2><a class="header" href="#tengine追加使用http2" id="tengine追加使用http2">Tengine追加使用Http2</a></h2>
<ol>
<li>
<p>获取Tengine源码，<code>git clone https://github.com/alibaba/tengine.git</code></p>
</li>
<li>
<p>执行编译</p>
<pre><code class="language-shell">cd tengine

./configure --with-http_ssl_module --with-http_v2_module # 如果还有其他参数也加上

make
</code></pre>
</li>
<li>
<p>检验结果</p>
<pre><code class="language-shell">cd objs

./nginx -v
Tengine version: Tengine/x.x.x (nginx/x.x.x) # 提示：x.x.x为版本号

./nginx -V
结果列表有 ngx_http_v2_module (static) 代表 HTTP/2 编译模块通过
</code></pre>
</li>
<li>
<p>替换旧nginx</p>
<pre><code class="language-shell"># 当前还在objs目录
sudo cp -f nginx /usr/local/nginx/sbin
</code></pre>
</li>
<li>
<p>进入nginx配置文件，启用http2</p>
<pre><code class="language-shell"># listen 443 ssl;
# 改为
listen 443 http2 ssl;
</code></pre>
</li>
<li>
<p>保存配置文件，检查是否正确<code>nginx -t</code>，然后重启<code>nginx -s reload</code></p>
</li>
<li>
<p>右键打开safari浏览器的<code>检查元素</code>，访问或刷新要启用http2的域名，在<code>网络</code>一栏里，对应的域名的有一列<code>协议</code>（如果没有就右键添加进去）显示h2证明启用成功。<em><strong>如果还是http/1.1，说明没有启用成功，看看nginx是否重启正确。</strong></em></p>
</li>
</ol>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/e6JBVrU.gif!web" alt="img" /></p>
<p>原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。</p>
<p>有很多同学微信问我，Linux命令这么多，该怎么从入门到精通？其实，这个事情非常的simple，这篇文章将会带你飞。文章非常的长，要挑一个阳光明媚的sunshine weekend，耐心去搞定。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/zaQzeue.png!web" alt="img" /></p>
<p>本文将由一个Linux命令概览开始，说明Linux命令的方方面面。如果你读完这部分还是一头雾水，那么就证明需要按照下面的小白教程去学习了，内容涵盖了：如何挑选Linux发行版、如何安装Linux系统，按照主题学习Linux系统的命令等。</p>
<p>入门后的 **学习方式：多敲多打，用条件反射替代大脑记忆--如果你将来或者现在要用它来吃饭的话。**其中，也有一些难啃的骨头，关注小姐姐味道微信公众号，我们一起用锋利的牙齿，来把它嚼碎。</p>
<h2><a class="header" href="#1-linux命令概览" id="1-linux命令概览">1. Linux命令概览</a></h2>
<p>这部分是给稍微有点Linux经验的同学准备的，如果你是初学者，请跳过此part直接进入第二部分。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/quM7Rry.png!web" alt="img" /></p>
<h2><a class="header" href="#11目录操作" id="11目录操作">1.1目录操作</a></h2>
<p>工作中，最常打交道的就是对目录和文件的操作。linux提供了相应的命令去操作他，并将这些命令抽象、缩写。</p>
<h3><a class="header" href="#111-基本操作" id="111-基本操作">1.1.1 基本操作</a></h3>
<p>可能是这些命令太常用了，多打一个字符都是罪过。所以它们都很短，不用阿拉伯数字，一个剪刀手就能数过来。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/fmaquai.png!web" alt="img" /></p>
<p>看命令。</p>
<p>mkdir创建目录  make dir <strong>cp</strong> 拷贝文件  copy <strong>mv</strong> 移动文件  move <strong>rm</strong> 删除文件 remove </p>
<p>例子：</p>
<pre><code># 创建目录和父目录a,b,c,d
mkdir -p a/b/c/d

# 拷贝文件夹a到/tmp目录
cp -rvf a/ /tmp/

# 移动文件a到/tmp目录，并重命名为b
mv -vf a /tmp/b

# 删除机器上的所有文件
rm -rvf /
</code></pre>
<h3><a class="header" href="#112-漫游" id="112-漫游">1.1.2 漫游</a></h3>
<p>linux上是黑漆漆的命令行，依然要面临人生三问：我是谁？我在哪？我要去何方？</p>
<p><code>ls</code> 命令能够看到当前目录的所有内容。 <code>ls -l</code> 能够看到更多信息，判断你是谁。 </p>
<p><code>pwd</code> 命令能够看到当前终端所在的目录。告诉你你在哪。 </p>
<p><code>cd</code> 假如你去错了地方，cd命令能够切换到对的目录。 </p>
<p><code>find</code> find命令通过筛选一些条件，能够找到已经被遗忘的文件。 </p>
<p>至于要去何方，可能就是主宰者的意志了。</p>
<h2><a class="header" href="#12-文本处理" id="12-文本处理">1.2 文本处理</a></h2>
<p>这是是非常非常加分的技能。get到之后，也能节省更多时间来研究面向对象。小姐姐味道已经输出了“最常用的vim、sed、awk技巧系列”。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/RJNzMfN.png!web" alt="img" /></p>
<h3><a class="header" href="#121-查看文件" id="121-查看文件">1.2.1 查看文件</a></h3>
<p>cat </p>
<p>最常用的就是 <code>cat</code> 命令了，注意，如果文件很大的话，cat命令的输出结果会疯狂在终端上输出，可以多次按 <code>ctrl+c</code> 终止。 </p>
<pre><code># 查看文件大小
du -h file

# 查看文件内容
cat file
</code></pre>
<p>less </p>
<p>既然cat有这个问题，针对比较大的文件，我们就可以使用 <code>less</code> 命令打开某个文件。类似vim，less可以在输入 <code>/</code> 后进入查找模式，然后按 <code>n</code> (N)向下(上)查找。 </p>
<p>有许多操作，都和vim类似，你可以类比看下。</p>
<p>tail </p>
<p>大多数做服务端开发的同学，都了解这么命令。比如，查看nginx的滚动日志。</p>
<pre><code>tail -f access.log
</code></pre>
<p>tail命令可以静态的查看某个文件的最后n行，与之对应的，head命令查看文件头n行。但head没有滚动功能，就像尾巴是往外长的，不会反着往里长。</p>
<pre><code>tail -n100 access.log
head -n100 access.log
</code></pre>
<h3><a class="header" href="#121-统计" id="121-统计">1.2.1 统计</a></h3>
<p>sort和uniq经常配对使用。sort可以使用 <code>-t</code> 指定分隔符，使用 <code>-k</code> 指定要排序的列。 </p>
<p>下面这个命令输出nginx日志的ip和每个ip的pv，pv最高的前10</p>
<pre><code># 2019-06-26T10:01:57+08:00|nginx001.server.ops.pro.dc|100.116.222.80|10.31.150.232:41021|0.014|0.011|0.000|200|200|273|-|/visit|sign=91CD1988CE8B313B8A0454A4BBE930DF|-|-|http|POST|112.4.238.213

awk -F&quot;|&quot; '{print $3}' access.log | sort | uniq -c | sort -nk1 -r | head -n10
</code></pre>
<h3><a class="header" href="#123-其他" id="123-其他">1.2.3 其他</a></h3>
<p>grep </p>
<p>grep用来对内容进行过滤，带上 <code>--color</code> 参数，可以在支持的终端可以打印彩色，参数 <code>n</code> 则输出具体的行数，用来快速定位。 </p>
<p>比如：查看nginx日志中的POST请求。</p>
<pre><code>grep -rn --color POST access.log
</code></pre>
<p>推荐每次都使用这样的参数。</p>
<p>如果我想要看某个异常前后相关的内容，就可以使用ABC参数。它们是几个单词的缩写，经常被使用。 <strong>A</strong> after  内容后n行 <strong>B</strong> before  内容前n行 <strong>C</strong> count?  内容前后n行 </p>
<p>就像是这样：</p>
<pre><code>grep -rn --color Exception -A10 -B2   error.log
</code></pre>
<h4><a class="header" href="#diff" id="diff">diff</a></h4>
<p>diff命令用来比较两个文件是否的差异。当然，在ide中都提供了这个功能，diff只是命令行下的原始折衷。对了，diff和patch还是一些平台源码的打补丁方式，你要是不用，就pass吧。</p>
<h2><a class="header" href="#13压缩" id="13压缩">1.3压缩</a></h2>
<p>为了减小传输文件的大小，一般都开启压缩。linux下常见的压缩文件有tar、bzip2、zip、rar等，7z这种用的相对较少。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/maUvEfE.png!web" alt="img" /></p>
<p>.tar使用tar命令压缩或解压 </p>
<p>.bz2使用bzip2命令操作 </p>
<p>.gz使用gzip命令操作 </p>
<p>.zip使用unzip命令解压 </p>
<p>.rar使用unrar命令解压 </p>
<p>最常用的就是 <code>.tar.gz</code> 文件格式了。其实是经过了tar打包后，再使用gzip压缩。 </p>
<p>创建压缩文件</p>
<pre><code>tar cvfz  archive.tar.gz dir/
</code></pre>
<p>解压</p>
<pre><code>tar xvfz. archive.tar.gz
</code></pre>
<p>快去弄清楚它们的关系吧。</p>
<h2><a class="header" href="#14-日常运维" id="14-日常运维">1.4 日常运维</a></h2>
<p>开机是按一下启动按钮，关机总不至于是长按启动按钮吧。对了，是shutdown命令，不过一般也没权限-.-!。passwd命令可以用来修改密码，这个权限还是可以有的。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/EnQjiuE.png!web" alt="img" /></p>
<p>mount </p>
<p>mount命令可以挂在一些外接设备，比如u盘，比如iso，比如刚申请的ssd。可以放心的看小电影了。</p>
<pre><code>mount /dev/sdb1 /xiaodianying
</code></pre>
<p>chown </p>
<p><code>chown</code> 用来改变文件的所属用户和所属组。 </p>
<p><code>chmod</code> 用来改变文件的访问权限。 </p>
<p>这两个命令，都和linux的文件权限777有关。</p>
<p>示例：</p>
<pre><code># 毁灭性的命令
chmod 000 -R /

# 修改a目录的用户和组为 xjj
chown -R xjj:xjj a

# 给a.sh文件增加执行权限（这个太常用了)
chmod a+x a.sh
</code></pre>
<p>yum </p>
<p>假定你用的是centos，则包管理工具就是yum。如果你的系统没有wget命令，就可以使用如下命令进行安装。</p>
<pre><code>yum install wget -y
</code></pre>
<p>systemctl </p>
<p>当然，centos管理后台服务也有一些套路。 <code>service</code> 命令就是。 <code>systemctl</code> 兼容了 <code>service</code> 命令，我们看一下怎么重启mysql服务。 推荐用下面这个。 </p>
<pre><code>service mysql restart
systemctl restart  mysqld 
</code></pre>
<p>对于普通的进程，就要使用kill命令进行更加详细的控制了。kill命令有很多信号，如果你在用 <code>kill -9</code> ，你一定想要了解 <code>kill -15</code> 以及 <code>kill -3</code> 的区别和用途。 </p>
<p>su </p>
<p>su用来切换用户。比如你现在是root，想要用xjj用户做一些勾当，就可以使用su切换。</p>
<pre><code>su xjj
su - xjj
</code></pre>
<p><code>-</code> 可以让你干净纯洁的降临另一个账号，不出意外，推荐。 </p>
<h2><a class="header" href="#15-系统状态概览" id="15-系统状态概览">1.5 系统状态概览</a></h2>
<p>登陆一台linux机器，有些命令能够帮助你快速找到问题。这些命令涵盖内存、cpu、网络、io、磁盘等。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/ieUBNnz.png!web" alt="img" /></p>
<p>unameuname命令可以输出当前的内核信息，让你了解到用的是什么机器。 </p>
<pre><code>uname -a
</code></pre>
<p>ps </p>
<p>ps命令能够看到进程/线程状态。和top有些内容重叠，常用。</p>
<pre><code># 找到java进程
ps -ef|grep java
</code></pre>
<p>top系统状态一览，主要查看。cpu load负载、cpu占用率。使用内存或者cpu最高的一些进程。下面这个命令可以查看某个进程中的线程状态。 </p>
<pre><code>top -H -p pid
</code></pre>
<p>free </p>
<p>top也能看内存，但不友好，free是专门用来查看内存的。包括物理内存和虚拟内存swap。</p>
<p>df </p>
<p>df命令用来查看系统中磁盘的使用量，用来查看磁盘是否已经到达上限。参数 <code>h</code> 可以以友好的方式进行展示。 </p>
<pre><code>df -h
</code></pre>
<p>ifconfig </p>
<p>查看ip地址，不啰嗦，替代品是 <code>ip addr</code> 命令。 </p>
<p>ping </p>
<p>至于网络通不通，可以使用ping来探测。（不包括那些禁ping的网站）</p>
<p>netstat虽然ss命令可以替代netstat了，但现实中netstat仍然用的更广泛一些。比如，查看当前的所有tcp连接。 </p>
<pre><code>netstat -ant
</code></pre>
<p>此命令，在找一些 <code>本地起了什么端口</code> 之类的问题上，作用很大。 </p>
<h2><a class="header" href="#16-工作常用" id="16-工作常用">1.6 工作常用</a></h2>
<p>还有一些在工作中经常会用到的命令，它们的出现频率是非常高的 ，都是些熟面孔。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/uQzAfqU.png!web" alt="img" /></p>
<p>export </p>
<p>很多安装了jdk的同学找不到java命令， <code>export</code> 就可以帮你办到它。export用来设定一些环境变量，env命令能看到当前系统中所有的环境变量。比如，下面设置的就是jdk的。 </p>
<pre><code>export PATH=$PATH:/home/xjj/jdk/bin
</code></pre>
<p>有时候，你想要知道所执行命令的具体路径。那么就可以使用whereis命令，我是假定了你装了多个版本的jdk。</p>
<p>crontab </p>
<p>这就是linux本地的job工具。不是分布式的，你要不是运维，就不要用了。比如，每10分钟提醒喝茶上厕所。</p>
<pre><code>*/10 * * * * /home/xjj/wc10min
</code></pre>
<p>datedate命令用来输出当前的系统时间，可以使用-s参数指定输出格式。但设置时间涉及到设置硬件，所以有另外一个命令叫做 <code>hwclock</code> 。 </p>
<p>xargsxargs读取输入源，然后逐行处理。这个命令非常有用。举个栗子，删除目录中的所有class文件。 </p>
<pre><code>find . | grep .class$ | xargs rm -rvf

#把所有的rmvb文件拷贝到目录
ls *.rmvb | xargs -n1 -i cp {} /mount/xiaodianying
</code></pre>
<h2><a class="header" href="#17-网络" id="17-网络">1.7 网络</a></h2>
<p>linux是一个多作业的网络操作系统，所以网络命令有很多很多。工作中，最常和这些打交道。</p>
<p>ssh </p>
<p>这个，就不啰嗦了。你一定希望了解 <code>ssh隧道</code> 是什么。你要是想要详细的输出过程，记得加参数 <code>-v</code> 。 </p>
<p>scp </p>
<p>scp用来进行文件传输。也可以用来传输目录。也有更高级的 <code>sftp</code> 命令。 </p>
<pre><code>scp a.txt 192.168.0.12:/tmp/a.txt
scp -r a_dir 192.168.0.12:/tmp/
</code></pre>
<p>wget </p>
<p>你想要在服务器上安装jdk，不会先在本地下载下来，然后使用scp传到服务器上吧（有时候不得不这样）。wget命令可以让你直接使用命令行下载文件，并支持断点续传。</p>
<pre><code>wget -c http://oracle.fuck/jdk2019.bin
</code></pre>
<p>mysql </p>
<p>mysql应用广泛，并不是每个人都有条件用上 <code>navicat</code> 的。你需要了解mysql的连接方式和基本的操作，在异常情况下才能游刃有余。 </p>
<pre><code>mysql -u root -p -h 192.168.1.2
</code></pre>
<p>不要觉得复杂，命令是有限的，但激情无限；都会也不要骄傲，一个vim就够折腾一辈子。捷径就是总结，深入只有探索。白马过隙，终会行云流水，手到擒来。</p>
<p>物是人非，年华易老。唯有时光，不会辜负。</p>
<h2><a class="header" href="#2-挑选一个linux发行版" id="2-挑选一个linux发行版">2. 挑选一个Linux发行版</a></h2>
<p>和Linux比较像的还有Unix，但如果你是一个二三十岁的小青年，你接触到可能只有Linux的世界了。从手机，到服务器上广泛使用的 <code>centos</code> ，到漂亮的桌面发行版 <code>ubuntu</code> ，甚至是风靡全球的 <code>树莓派</code> ，到处都是linux的身影。 </p>
<h2><a class="header" href="#21-你需要知道这些linux历史" id="21-你需要知道这些linux历史">2.1 你需要知道这些linux历史</a></h2>
<p>知道一点相关操作系统的历史，是能够陶冶情操的。 <code>GNU/Linux</code> 是为了抵制一些商业公司的垄断行为而发展起来的，凝结了一代互联网人向往自由的心血。 </p>
<p>和其他Unix比起来，Linux其实很年轻。直到 <strong>1991</strong> 年，一个叫 <code>Linus Torvalds</code> 的芬兰年轻人才开始开发我们现在所知道的 <code>Linux内核</code> 。 </p>
<p><code>Linux</code> 的吉祥物是企鹅，这个吉祥物直到 <strong>1996</strong> 年才确定，所以你会经常看到一些搞笑的图片。如果你是90后，那这只小企鹅几乎和你一般大，还是个年轻的小伙。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/ENvQRjj.png!web" alt="img" /></p>
<p>Linux的发展历程比较的复杂。经过一次次的过关斩将，Linux走到今天确属不易。关于其发展历史，你可以通过下面的链接，查看高清图片。20年的时间，对软件行业来说，是一段非常漫长的时光，有多少的风光已经物是人非。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/r67Zfyf.png!web" alt="img" /></p>
<p>高清见图片(http://1t.click/aUnx) 。可以看到，linux只占了那可怜的一小块。这就像人类的出现，在生命的长河中，微不足道，但却是一个质的飞跃。 </p>
<p>你可能注意到，在前面的描述中，说的是 <code>GUN/Linux</code> ，而不仅仅是 <code>Linux</code> 。Linux本身只是一个内核，作用有限，只有和 <code>GNU</code> 联合起来，拥有完整的生态才会发挥它的作用。 </p>
<p>谈到上面区别的原因，是为了记住 <code>Richard Stallman</code> 在1983年发起的 <code>GNU</code> 计划。他同时是 <code>smalltalk</code> 语言的发明者，被公认的第二个面向对象的语言。我在早些年，还研究过一段时间。哦，他还编写了一个巨无霸编辑器， <code>Emacs</code> 。 </p>
<p>只有一个人被捧成神，他才会有能量折磨你。</p>
<p>针对于Linux历史，我们不做过多介绍。下面介绍几个经典的发行版本。</p>
<h2><a class="header" href="#22-精选版本介绍" id="22-精选版本介绍">2.2 精选版本介绍</a></h2>
<p>现在的Linux发行版本，已经有上千个，你要是喜欢、而且多金，你也可以做一个。如何在这其中，找到最合适的版本，是需要经过一番折腾的。很多发行版本，其实是很小众的。</p>
<p>这不像是哲学领域的某些东西，真理掌握在少数人手中。只有获得良好发展，并得到认可的Linux发行版，才有它的价值，可以说是彻头彻尾的实用主义。</p>
<p>但这东西又像女朋友，刚开始感觉风采迥异，各有千秋，到最后了解到是一样的庸俗不堪。但有人就是喜欢Linux相关的工作，一干就是一辈子...</p>
<p>我可以先说一下自己的历程。刚开始，接触的是红帽 <code>redhat</code> ，当时还没有分什么企业版。用了一段时间以后，又切换成更稳定的 <code>slackware</code> 。但是slackware上的程序更新实在太慢了，于是又切换成readhat血统的 <code>fedora</code> ，这个版本的软件保鲜度很高。其间，又尝试了其他几个linux版本，最终，在2013年前后，换成了滚动升级的 <code>archlinux</code> ，直到现在。 </p>
<p>要我个人做个推荐的话：</p>
<p>1、个人用户（技术），桌面版用 <code>ubuntu</code> =&gt; <code>archlinux</code> 。 </p>
<p>2、企业用户，服务器，使用 <code>centos</code> 。 </p>
<h2><a class="header" href="#23-主要起源" id="23-主要起源">2.3 主要起源</a></h2>
<p>这么多Linux版本，其实有两条主线。 <code>debian</code> 系列和 <code>redhat</code> 系列。很多发行版本，其实是二次翻新，很多就直接拿这两个基础系列进行改造。正所谓： <strong>操作系统千千万，都是帽子和大便。</strong></p>
<h3><a class="header" href="#debian" id="debian">debian</a></h3>
<p>下面这个屎一样的图表，就是debian。呃呃呃，和大便只差一个字母。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/BbMZVzV.png!web" alt="img" /></p>
<p><code>Debian计划</code> 是一个致力于创建一个自由操作系统的合作组织。它的特点是：稳定、安全，到现在为止，已经发展了20多年了。我们所熟悉的ubuntu，就是基于debian改进的。 </p>
<h3><a class="header" href="#redhat" id="redhat">redhat</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/ERzQ7jm.png!web" alt="img" /></p>
<p>红帽是一家商业公司，涉足Linux比较早，现在对个人提供一些 <code>红帽认证</code> 之类的证书。现在云主机使用较多的centos，包括红帽公司的 <code>RHEL</code> ，占据了大部分服务器市场。近期， <code>centos 8</code> 推出了 <code>centos stream</code> 滚动版本，看起来更像是一个正常的操作系统。 </p>
<h2><a class="header" href="#24-典型版本" id="24-典型版本">2.4 典型版本</a></h2>
<p>我们看一下处于不同层次的几个典型版本。从应用方面来说，linux有桌面、服务器、研究用等用途。</p>
<h3><a class="header" href="#241ubuntu" id="241ubuntu">2.4.1、ubuntu</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/Avu2yeF.png!web" alt="img" /></p>
<p>ubuntu的出现，对Linux的推广有不可磨灭的贡献。它是一个易于安装的桌面版本（也有服务器版本），界面非常漂亮。ubuntu是基于debian系统的unstable分支修改的，包管理软件是 <code>apt-get</code> 。 </p>
<p>它的创建者是 <code>Mark Shuttleworth</code> ，南非企业家，世界上第二名自资的太空游客。我想，无论是太空还是ubuntu，这都是梦想吧。 </p>
<h3><a class="header" href="#242centos" id="242centos">2.4.2、centos</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/6RB32iZ.png!web" alt="img" /></p>
<p>centos是目前最流行的服务器版本。它是RHEL源代码再编译的产物，主要是为了绕开一些法律问题。在包管理，甚至稳定性上，与红帽企业版没什么差别。</p>
<h3><a class="header" href="#243archlinux" id="243archlinux">2.4.3、archlinux</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/7jimim6.png!web" alt="img" /></p>
<p>archlinux采用 <code>滚动升级</code> 的模式进行发行，尽全力提供最新的稳定版本。刚开始安装，arch只提供一个基本的系统，甚至连界面都没有，对初学者不是很友好。 </p>
<p>但是，archlinux是非常干净的系统。很多软件，只有你需要的时候才会安装。它的软件和理念通常都是最新的，定制化非常强，深得许多Linux爱好者的喜爱。</p>
<h3><a class="header" href="#244gentoo" id="244gentoo">2.4.4、gentoo</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/aiErIrJ.png!web" alt="img" /></p>
<p>上面的archlinux，提供了编译后的软件包。用户在安装软件时，只需要下载、解压即可。gentoo将这个过程更近一步，可以说更加的变态。它下载的是软件的源代码，然后在本地进行编译，然后安装。 </p>
<p>这通常非常的蛋疼，因为下载、编译会花费非常长的时间，但它有一个非常大的优点，就是稳定。</p>
<p>这个系统比较底层，对技能要求更多，不太推荐。</p>
<h3><a class="header" href="#245-lfs" id="245-lfs">2.4.5 、LFS</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/riIr63J.png!web" alt="img" /></p>
<p>LFS的全拼是“linux from scratch”，意思是从零构建一个linux系统。它有一个非常详细的安装文档，教你怎样编译内核，编译引导程序，编译和配置必要的软件。 </p>
<p>这是一个疯狂而必要的过程。如果你想要自己的Linux之上更上层楼，跟着文档做一遍是受益无穷的。你需要经过多次交叉编译，最终使用chroot命令切换到新系统进行后续操作。</p>
<p>想做一个自己的发行版么？从这开始吧。</p>
<h3><a class="header" href="#246kali" id="246kali">2.4.6、kali</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/Efyeeem.png!web" alt="img" /></p>
<p>kali linux是一个非常专业的发行版。如果你在做渗透方面的工作，将是一个非常好的选择。</p>
<p>发行版的安装包非常大，包含了常见的破解工具，渗透工具，攻击工具。这非常的危险，我曾用它暴力破解了非常多的wifi密码，成功的窥视了邻居的隐私。还是非常好用的。</p>
<h2><a class="header" href="#3-安装一个清爽的linux系统" id="3-安装一个清爽的linux系统">3. 安装一个清爽的Linux系统</a></h2>
<p>工欲善其事，必先利其器。你可能会想到买一台云主机练练手，但那毕竟要花点银子，我们可以自己安装一个。我们在上面提到，目前使用最广泛的，就是 <code>centos</code> 。不论你是自建机房，还是使用类似于阿里云这样的云端环境，大多数都会提供 <code>centos</code> 的安装。 </p>
<p>你可能会找到多种安装虚拟机的方式。本小节，将使用 <code>虚拟双网卡</code> 的方式，准备一个纯洁的环境。这一小节，图片很多。 </p>
<p>以阿里云为例，默认第一位就是CentOS，提供了从7.6版本到旧版本的多个镜像。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/zENFvan.png!web" alt="img" /></p>
<h2><a class="header" href="#31-下载" id="31-下载">3.1 下载</a></h2>
<p>下面的文章，我们就以 <code>CentOS 7</code> 稳定版本为基础环境。centos很流行，所以镜像也有很多。国内，我们从上海交大下载，速度应该会快一些。 </p>
<pre><code>http://ftp.sjtu.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1908.iso
</code></pre>
<p>如果交大哪天不维护了。可以从这里找：</p>
<pre><code>http://centos.mirror.ndchost.com/7/isos/x86_64/CentOS-7-x86_64-Minimal-1908.iso
</code></pre>
<p>为了让大家学到更多的知识，我们使用 <code>最小化</code> 的系统ISO。最小化的iso不到 <code>1GB</code> ，而预装了很多软件的dvd有 <code>4.3GB</code> 的大小。我们就用这个减肥版。 </p>
<h2><a class="header" href="#32-安装linux" id="32-安装linux">3.2 安装Linux</a></h2>
<p>要想快速学习、体验Linux，最便捷的方式，就是使用虚拟机进行安装。目前，最流行的虚拟机，一个是 <code>VMware</code> ，一个是 <code>VirtualBox</code> 。在MacOS上还有一个 <code>Parallels Desktop</code> 。 </p>
<p>其中，VirtualBox免费而且跨平台，能够满足我们的需求。接下来，将一步步引导你进行安装。</p>
<h4><a class="header" href="#1-点击新建开启安装旅程" id="1-点击新建开启安装旅程">(1) 点击新建，开启安装旅程。</a></h4>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/URBFji.png!web" alt="img" /></p>
<h4><a class="header" href="#2-填写名称版本然后点击继续" id="2-填写名称版本然后点击继续">(2) 填写名称，版本。然后点击继续。</a></h4>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/qYfiUzJ.png!web" alt="img" /></p>
<h4><a class="header" href="#3按照你的机器配置选择内存" id="3按照你的机器配置选择内存">(3)按照你的机器配置，选择内存</a></h4>
<p>我的机器是8GB内存的，就分配给虚拟机2GB，这个已经足够用了。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/RVVniiB.png!web" alt="img" /></p>
<h4><a class="header" href="#4-创建一个虚拟磁盘" id="4-创建一个虚拟磁盘">(4) 创建一个虚拟磁盘</a></h4>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/2EZJJf.png!web" alt="img" /></p>
<p>点击继续后，将弹出一个对话框。我们不用多管，一直点继续，知道对话框消失。这非常的粗暴。 </p>
<h4><a class="header" href="#5-接下来点击设置" id="5-接下来点击设置">(5) 接下来，点击设置。</a></h4>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/AvIF7bB.png!web" alt="img" /></p>
<h4><a class="header" href="#6-切换到storage选项选择我们下载的iso" id="6-切换到storage选项选择我们下载的iso">(6) 切换到Storage选项，选择我们下载的iso</a></h4>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/jYr26jm.png!web" alt="img" /></p>
<h4><a class="header" href="#7-点击启动开始安装" id="7-点击启动开始安装">(7) 点击启动，开始安装。</a></h4>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/6reuuee.png!web" alt="img" /></p>
<p>使用方向键切换，使得高亮聚焦在 <code>Install CentOS 7</code> 上。点击确定，开始安装。 </p>
<h4><a class="header" href="#8-弹出一个安装界面" id="8-弹出一个安装界面">(8) 弹出一个安装界面</a></h4>
<p>接下来的步骤有点多，如果我们没有特别的介绍，那么直接continue就ok了。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/uEFfEz.png!web" alt="img" /></p>
<h4><a class="header" href="#9-接下来配置磁盘分区" id="9-接下来配置磁盘分区">(9) 接下来，配置磁盘分区</a></h4>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/jY32yma.png!web" alt="img" /></p>
<p>依然保持默认，并按按钮 <code>Done</code> 退出。 </p>
<h4><a class="header" href="#10-配置用户" id="10-配置用户">(10) 配置用户</a></h4>
<p>linux上默认的用户名为 <code>root</code> 。接下来我们设置root用户的密码为 <code>123456</code> 。由于这是一个弱密码，所以需要点击两次确定退出。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/Zbumaiv.png!web" alt="img" /></p>
<h4><a class="header" href="#11-等待安装完毕进行重启" id="11-等待安装完毕进行重启">(11) 等待安装完毕，进行重启</a></h4>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/uMZFB3r.png!web" alt="img" /></p>
<h4><a class="header" href="#12-安装成功" id="12-安装成功">(12) 安装成功</a></h4>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/ABvABjB.png!web" alt="img" /></p>
<h2><a class="header" href="#33-联网" id="33-联网">3.3 联网</a></h2>
<p>这个时候，我们安装的虚拟机，还不能联网，无法把自己的意念传达出去。由于我们没有对虚拟机进行任何设置，所以使用的是默认的 <code>NAT</code> 模式。 </p>
<p>将光标聚焦到命令行窗口，然后输入命令 <code>dhclient</code> 。等待几秒钟，执行 <code>ping baidu.com</code> 测试以下网络，可以看到能够正常访问网络了。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/AjeyYz.png!web" alt="img" /></p>
<p>上面黑漆漆的窗口，就是我们现在的Linux界面。有人觉得很丑，就像是在玩dos，但像我这种不可救药的人，却觉得格外的亲切。</p>
<p>接下来的命令，我们不会再截图，而使用高亮的代码块表示。为了不至于让人晕头转向，请先看下图。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/ZZ7FFvq.png!web" alt="img" /></p>
<h2><a class="header" href="#34-外部访问虚拟机" id="34-外部访问虚拟机">3.4 外部访问虚拟机</a></h2>
<p>由于 <code>NAT</code> 模式的特点，我们的虚拟机能够访问外网，但无法被外部发现。酒香竟怕巷子深。为了解决这个问题，我们需要再添加一块网卡。 </p>
<p>在做这些更改之前，需要首先关闭虚拟机。可以强制关闭机器，也可以在命令行中输入：</p>
<pre><code>shutdown -h now
</code></pre>
<p>虚拟机关闭后，再次点击设置，切换到网络适配器选项卡。如图，添加一个新的网络适配器，适配器类型为 <code>Host-only Adapter</code> 。通过这块网卡，我们的宿主机就能够访问它了。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/IJf6nyB.png!web" alt="img" /></p>
<p>再次启动虚拟机，执行 <code>dhclient</code> 命令后，执行 <code>ip addr</code> 查看主机的ip地址。可以看到，我们现在有两块网卡，两个ip地址。 </p>
<p>记录下192打头的网络地址，我们会使用外部的程序，比如 <code>XShell</code> 、 <code>SecureCRT</code> 等，进行连接。比如，我这里的ip地址是： <code>192.168.99.100</code> 。不废话，看图。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/EFJFzym.png!web" alt="img" /></p>
<p>小提示：关于虚拟网卡的网段，如果有差异。你可以在全局设置里，改成和我一样的。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/uEJVv2u.png!web" alt="img" /></p>
<h2><a class="header" href="#35-远程连接" id="35-远程连接">3.5 远程连接</a></h2>
<p>你可能已经体验到，通过虚拟机自带的命令行界面进行输入，局限性非常大。通过远程连接，可以把终端界面切换到我们熟悉的操作模式，如果能够显示彩色的终端，那再好不过了。下面介绍几个工具，一般的，使用xshell的居多。</p>
<h4><a class="header" href="#windows" id="windows">Windows</a></h4>
<ul>
<li><code>XShell</code> 你可能在公司内，见过你的SRE同事，运指如飞，命令字符如流水一般撒过屏幕。即使非常繁杂，难以记忆的密码，也能瞬间输入。他可能用的就是xshell。 </li>
<li><code>SecureCRT</code> 比较老的一款产品，使用也较多。 </li>
<li><code>MobaXterm</code> MobaXterm就是一单文件纯绿色软件，下载过来exe包直接运行即可，不需要任何的安装过程。 </li>
</ul>
<p>它们都有免费版和专业版之分。无力购买的话，就找找破解版。但是注意，盗版汉化的ssh客户端，有些别有用心的人会在软件中植入木马，窃取你的密码、证书，这种情况已经发生过很多次。</p>
<h4><a class="header" href="#macos" id="macos">MacOS</a></h4>
<p>对于macos用户来说，简单的很。直接使用iTerm，输入命令行即可。比如使用下面的命令连接我们的机器。</p>
<pre><code>ssh root@192.168.99.100
</code></pre>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/uYZfQ3V.gif!web" alt="img" /></p>
<h4><a class="header" href="#linux" id="linux">Linux</a></h4>
<p>唔，你都已经是Linux环境了，还折腾个啥虚拟机呢？直接用吧。</p>
<p>推荐使用XShell、SecureCRT、iTerm等工具，通过ssh进行远程连接。对于一些命令拷贝、验证来说，要方便快捷的多。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/YvyyiyB.png!web" alt="img" /></p>
<h2><a class="header" href="#4-对linux命令行有个初步了解" id="4-对linux命令行有个初步了解">4. 对Linux命令行有个初步了解</a></h2>
<p>万事开头难。面对黑漆漆的Linux窗口，要勇敢的走出第一步。不要怕输错了什么，系统健壮的很。命令行通常会拥有比图形界面更高的效率，更加重要的是它可以做自动化之类的小工具，这使得生产力产生质的飞跃。</p>
<p>现在，你已经安装好了centos，并远程连接上了它。我们拥有了它，但并不能了解它的脾气。接下来，让我们进入Linux命令行的世界。和我签订契约吧，少年。</p>
<p>本小节会使用非常详细的演进方式，来看一下一个命令，是怎样生成和执行的。</p>
<h2><a class="header" href="#41简单尝试" id="41简单尝试">4.1、简单尝试</a></h2>
<p>好啦，我们现在就在终端里了。什么叫做终端呢？你在很多黑客电影里，看到的黑漆漆的界面就是，它提供了一个可以输入字符串的交互式界面，至于那些闪光的、扫描机一样的东西，是不存在的。</p>
<p>尝试输入些什么吧。 比如： <code>jdsjf</code> 。 </p>
<pre><code>[root@localhost ~]# jdsjf
-bash: jdsjf: command not found
</code></pre>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/aI3Unam.png!web" alt="img" /></p>
<p>我们再次把这张图贴一下。怎么回事？命令的输出翻译成中文，就是“找不到命令”的意思。什么叫命令？就是我们上面随便输入的字符串 <code>jdsjf</code> 。 </p>
<p>然后，我们看下提示中其他一些有用的东西。</p>
<p>↓↓↓↓↓↓</p>
<p>bash代表的是我们所使用的 <code>shell</code> ，shell可以认为是一个解释器，将我们的输入解释成一系列可执行的指令。现在的linux发行版，最流行的就是bash解释器，几乎每个都预装了它。 </p>
<p>命令找不到，证明我们的字符串bash解释不了。但是，Linux上一些目录里的文件，是可以被默认找到的，这些目录的集合，就叫 <code>PATH</code> 。PATH还是一个环境变量，我们可以通过命令查看它的尊容。 </p>
<pre><code>[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
</code></pre>
<p>想要知道系统中有哪些命令，就可以看下上面这些文件夹中，都有哪些文件。文件非常非常之多，但是大部分我们不会接触。所以，xjjdog才会写这么个东西--聚焦那些最常用，最有用的命令，最常用的参数，最有用的场景。</p>
<p>命令输出后，还有一些额外的东西，比如 <code>[root@localhost ~]</code> ，这部分叫做提示符，光标会一直跳动，等待你的输入。这部分是可以定制的，甚至可以定制的十分漂亮。 </p>
<h2><a class="header" href="#42hello-world" id="42hello-world">4.2、Hello World</a></h2>
<p>到现在为止，我们什么都没得到。按照程序员的想法来说，就要实现一个 <code>hello world</code> 的程序。在终端shell里，这个过程变得简单，远比写一个java程序简单。 </p>
<pre><code>[root@localhost ~]# echo &quot;Hello World&quot;
Hello World
</code></pre>
<p>如上所示， <code>echo</code> 的意思就是输出一些内容。后面的 <code>Hello World</code> ，就叫做参数，它们之间以空格分隔，可以接受多个参数。 </p>
<pre><code>[root@localhost ~]# echo &quot;Hello World&quot; , &quot;Fuck 996&quot;
Hello World , Fuck 996
</code></pre>
<p>以上命令能够正常运行，证明echo是我们的终端能够认识的一个命令。那到底这个命令是在什么地方呢？可以使用 <code>whereis</code> 命令进行查找。 </p>
<pre><code>[root@localhost ~]# whereis echo
echo: /usr/bin/echo /usr/share/man/man1/echo.1.gz
</code></pre>
<p>命令显示。我们的echo命令全路径，是 <code>/usr/bin/echo</code> ，由于它处于PATH目录中，所以能够被识别到。 </p>
<h2><a class="header" href="#43将命令加入path" id="43将命令加入path">4.3、将命令加入PATH</a></h2>
<p>接下来，我们把上面的命令，做成一个脚本。然后将这个脚本，放到PATH目录中。不过先等等，我们要先给命令起个名字。</p>
<p>首先需要创建一个文件。在Linux上，创建文件使用 <code>touch</code> 命令。 </p>
<pre><code>[root@localhost ~]# touch jdsjf
</code></pre>
<p>命令执行后，什么都没发生，它只是创建了一个空文件。接下来，我们向其中添加一些内容。</p>
<pre><code>[root@localhost ~]# echo &quot;echo 'Hello World'&quot; &gt; jdsjf
</code></pre>
<p>注意符号 <code>&gt;</code> ，它的意思是，将前面的输出，重定向到后面的文件中。执行完上面的命令， <code>jdsjf</code> 中的内容，就变成了 <code>echo 'Hello World</code> 。 </p>
<p>接下来，我们尝试着去执行刚才生成的命令。</p>
<pre><code>[root@localhost ~]# ./jdsjf
-bash: ./jdsjf : Permission denied
</code></pre>
<p>我们通过相对路径的方式，来执行刚刚生成的命令。结果，终端显示我们并没有这个命令的执行权限。</p>
<p>其实，Linux在权限控制这一方面，非常的详细。一个文件，有可读、可写、可执行三种属性。如果想要一个文件能够执行，需要给它添加执行权限，这个过程是由命令 <code>chmod</code> 完成的。 </p>
<pre><code>[root@localhost ~]# chmod u+x jdsjf
[root@localhost ~]# ./jdsjf
Hello World
</code></pre>
<p>我们将在后面的章节，来详细介绍权限方面的知识。如上所示，命令已经能正常输出，接下来，我们把命令 <code>移动</code> 到PATH中的一个目录。 </p>
<pre><code>[root@localhost ~]# mv jdsjf /usr/local/bin/
[root@localhost ~]# jdsjf
Hello World
</code></pre>
<p>不需要加任何的相对路径，现在，只需要输入jdsjf，就可以正常输出一串数字。我们成功的让一个没有任何意义的字符串，表达了它的想法。虽然我们依然是它的主宰。</p>
<p>你可以想一下下面这三个问题：</p>
<p>1、我可以自定义一个目录，比如 <code>/root/mybin</code> ，把它加入到PATH么？ </p>
<p>2、我可以省略上面的touch命令，直接使用重定向生成文件么？</p>
<p>3、除了放到PATH和相对路径，还有没有其他的命令执行方式？</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/nMBrUbz.png!web" alt="img" /></p>
<h2><a class="header" href="#5--linux漫游方式" id="5--linux漫游方式">5.  Linux漫游方式</a></h2>
<p>想要了解linux的基本使用方法，就要了解一个基本的事实--linux系统中，一切皆文件。</p>
<p>不管是命令，还是文档，甚至设备，目录，套接字，在linux上对它们的操作都是一致对待的。许多开发驱动程序的小伙伴，会发现使用的一些函数，和读写文件的没什么两样（open、close、read、write、ioctl）。今天我们所说的基本操作，针对的就是普通文件和目录，本小节将详细解释相关命令。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/vIBrQnF.png!web" alt="img" /></p>
<h2><a class="header" href="#51当前路径" id="51当前路径">5.1、当前路径</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/vMBJFfu.png!web" alt="img" /></p>
<p>到现在为止，我们还不知道自己在系统的什么地方。在浏览器上，我们能够通过导航栏上的url，了解到自己在互联网上的具体坐标。相似的功能，是由 <code>pwd</code> 命令提供的，它能够输出当前的工作目录。 </p>
<p><code>pwd</code> 命令是非常非常常用的命令，尤其是在一些 <code>命令提示符</code> 设置不太友好的机器上。另外，它也经常用在shell脚本中，用来判断当前的运行目录是否符合需求。 </p>
<p>有很多线上事故，都是由于没有确认当前目录所引起的。比如 <code>rm -rf *</code> 这种危险的命令。在执行一些高危命令时，随时确认当前目录，是个好的习惯。 </p>
<pre><code>[root@localhost ~]# pwd
/root
</code></pre>
<p>我们使用root用户默认登陆后，就停留在 <code>/root</code> 目录中。Linux中的目录层次，是通过 <code>/</code> 进行划分的。 </p>
<h2><a class="header" href="#52文件系统用户标准" id="52文件系统用户标准">5.2、文件系统用户标准</a></h2>
<p>Linux的文件系统，从一开始就有一个规范标准。它还有一个专有缩写名词，叫做 <code>FHS</code> (Filesystem Hierarchy Standard)。FHS经过多年的演进，目录结构也越来越清晰。除了一些标准的要求，还有一些使用者之间的约定。 </p>
<p>接下来，我们大体看一下linux上的默认目录，对其有一个基本的感觉。</p>
<table><thead><tr><th align="left">第1层</th><th align="left">第二层</th><th align="left">介绍</th></tr></thead><tbody>
<tr><td align="left">/bin</td><td align="left">目录/usr/bin的软链接</td><td align="left"></td></tr>
<tr><td align="left">/sbin</td><td align="left">目录/usr/sbin的软链接</td><td align="left"></td></tr>
<tr><td align="left">/lib</td><td align="left">目录/usr/lib的软链接</td><td align="left"></td></tr>
<tr><td align="left">/usr</td><td align="left">/bin</td><td align="left">存放一些常用的命令</td></tr>
<tr><td align="left">/usr</td><td align="left">/sbin</td><td align="left">存放一些管理员常用的命令</td></tr>
<tr><td align="left">/usr</td><td align="left">/lib</td><td align="left">用来存放动态库和一些模块文件</td></tr>
<tr><td align="left">/sys</td><td align="left">内核中的数据结构的可视化接口</td><td align="left"></td></tr>
<tr><td align="left">/proc</td><td align="left">内存映像</td><td align="left"></td></tr>
<tr><td align="left">/run</td><td align="left">内存映像</td><td align="left"></td></tr>
<tr><td align="left">/boot</td><td align="left">存放引导程序，内核相关文件</td><td align="left"></td></tr>
<tr><td align="left">/dev</td><td align="left">存放一些 <code>设备文件</code> ，比如光盘</td><td align="left"></td></tr>
<tr><td align="left">/etc</td><td align="left">用于存储一些全局的、应用的配置文件</td><td align="left"></td></tr>
<tr><td align="left">/var</td><td align="left">与/var/run一样，存放的是系统运行时需要的文件，比如mysql的pid等</td><td align="left"></td></tr>
<tr><td align="left">/tmp</td><td align="left">非常特殊的临时文件夹，断电丢失</td><td align="left"></td></tr>
<tr><td align="left">/home</td><td align="left">/**</td><td align="left">用户目录，比如我的目录是/home/xjjdog</td></tr>
<tr><td align="left">/root</td><td align="left">root用户的home目录</td><td align="left"></td></tr>
</tbody></table>
<ul>
<li><code>home</code> 平常，我们打交道最多的目录，就集中在自己的用户目录，我们可以在里面做任何操作，比如我们现在root用户的 <code>/root</code> 目录。一些自己的资料，比如视频、音频、下载的文件，或者做测试用的一些数据资料，就可以自行在这些目录下规划。root用户比较特殊，普通用户的私人目录都是在/home下的。 </li>
<li><code>/etc</code> etc目录是经常要打交道的目录，存放了一些全局的系统配置文件和应用配置文件。比如你安装了php，或者nginx，它们的配置文件就躺在/etc目录下的某个文件夹里。 </li>
<li><code>/var</code> var目录存放一些运行中的数据，有必须的，也有非必须的。一些黑客入侵之后，会在这里面的某些文件中留下痕迹，他们会着重进行清理。var目录还是一些应用程序的默认数据存放之地，比如mysql的数据文件。 </li>
<li><code>/tmp</code> 目录是一个特殊的临时目录，文件在断电以后就消失了。但这个目录，所有的用户，都有写入权限，通常用来做文件交换用。 </li>
<li><code>/proc</code> 和 <code>/sys</code> 目录，是两个神奇的目录。它们两个是一种伪文件系统，可以通过修改其中一些文件的状态和内容，来控制程序的行为（修改后会直接刷到内存上，太酷了）。刚开始的时候，只有proc目录，由于里面内容有多又乱，后面又规划出sys目录，用来控制内核的一些行为。如果你在调优一些系统参数，和这些文件打交道的时间比较多。 </li>
<li>还有几个空的目录，我们没有列在上面的表格上。比如 <code>/srv</code> 目录，通常会把一些web服务的资料，比如nginx的，放在这里面。但是，这并不是强制要求的，所以我见过的 <code>/srv</code> 目录，通常会一直是空的。同样的， <code>/opt</code> 目录也是这样一个存在，你就当它不存在就行。这都属于使用者规划的范畴，自定义性非常强。 </li>
<li>在使用Linux系统的时候，也可以创建自己的目录。比如，我就喜欢自己创建一个叫做 <code>/data</code> 的目录，用来存放一些数据库相关的内容。举个例子， <code>/data/mysql</code> 存放mariadb的数据，而 <code>/data/es/</code> 存放elasticsearch的索引内容。 </li>
</ul>
<p>linux上的文件类型有很多，它们大部分都分门别类的存放在相应的目录中，比如/dev目录下，就是一些设备文件；/bin文件下，是一些可以执行命令。通常都好记的很。</p>
<h2><a class="header" href="#53查看文件列表" id="53查看文件列表">5.3、查看文件列表</a></h2>
<p>所以，上面的表格内容，我是怎么看到的呢，靠记忆么？ <code>ls</code> 命令，能够列出相关目录的文件信息。可以被评为linux下最勤劳的命令标兵。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/iYbiiyj.png!web" alt="img" /></p>
<p>现在的终端，都能够输出彩色的信息，非常的直观。 <code>oh-my-zsh</code> 和 <code>oh-my-bash</code> 等项目，可以让你的终端更加的漂亮。把它加入到你的研究清单里吧。 </p>
<pre><code>[root@localhost /]# ls /
# 注意：ls可以接受路径参数，你不用先跳转，就可以输出相关信息
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@localhost /]# ls -l /
# 带上 -l参数，可以查看一些更加详细的信息。
total 20
lrwxrwxrwx.   1 root root    7 Nov  3 20:24 bin -&gt; usr/bin
dr-xr-xr-x.   5 root root 4096 Nov  3 20:34 boot
drwxr-xr-x.  19 root root 3080 Nov  3 21:19 dev
drwxr-xr-x.  74 root root 8192 Nov  3 20:34 etc
drwxr-xr-x.   2 root root    6 Apr 11  2018 home
lrwxrwxrwx.   1 root root    7 Nov  3 20:24 lib -&gt; usr/lib
lrwxrwxrwx.   1 root root    9 Nov  3 20:24 lib64 -&gt; usr/lib64
drwxr-xr-x.   2 root root    6 Apr 11  2018 media
drwxr-xr-x.   2 root root    6 Apr 11  2018 mnt
drwxr-xr-x.   2 root root    6 Apr 11  2018 opt
dr-xr-xr-x. 108 root root    0 Nov  3 21:19 proc
dr-xr-x---.   2 root root  135 Nov  4 07:53 root
drwxr-xr-x.  24 root root  740 Nov  3 21:20 run
lrwxrwxrwx.   1 root root    8 Nov  3 20:24 sbin -&gt; usr/sbin
drwxr-xr-x.   2 root root    6 Apr 11  2018 srv
dr-xr-xr-x.  13 root root    0 Nov  3 21:19 sys
drwxrwxrwt.   9 root root 4096 Nov  4 03:40 tmp
drwxr-xr-x.  13 root root  155 Nov  3 20:24 usr
drwxr-xr-x.  19 root root  267 Nov  3 20:34 var
</code></pre>
<p>ls最常用的，就是加参数 <code>l</code> 或者参数 <code>a</code> 。 </p>
<h3><a class="header" href="#531详细信息" id="531详细信息">5.3.1、详细信息</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/zyaQb2f.png!web" alt="img" /></p>
<p>加上参数 <code>l</code> ，能够看到文件的一些权限信息已经更新日期等。但我们还看到了一些更有意思的东西。比如： </p>
<pre><code>lib -&gt; usr/lib
</code></pre>
<p>上面表示的，是软链接信息。</p>
<p>就如同我们上面表格所展示的一样， <code>lib</code> 目录，是 <code>/usr/lib</code> 的快捷方式，它们之中的内容，没有什么两样。 </p>
<p>关于 <code>ls -l</code> 展示的更加详细的内容，可以参照我下面的这张图。我们将在了解后面小节的内容后，再次对这张图进行回顾。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/IfmyYbE.png!web" alt="img" /></p>
<h3><a class="header" href="#532-隐藏文件" id="532-隐藏文件">5.3.2 隐藏文件</a></h3>
<p>直接在你的/root目录里，执行 <code>ls -al</code> ，你会看到更多东西。这些额外的隐藏文件，都是以 <code>.</code>开头，以配置文件居多。这就是参数 <code>a</code> 的作用。 </p>
<pre><code>[root@localhost ~]# ls -al
total 28
dr-xr-x---.  2 root root  135 Nov  4 07:53 .
dr-xr-xr-x. 17 root root  224 Nov  3 20:28 ..
-rw-------.  1 root root 1273 Nov  3 20:28 anaconda-ks.cfg
-rw-------.  1 root root  246 Nov  4 11:41 .bash_history
-rw-r--r--.  1 root root   18 Dec 28  2013 .bash_logout
-rw-r--r--.  1 root root  176 Dec 28  2013 .bash_profile
-rw-r--r--.  1 root root  176 Dec 28  2013 .bashrc
-rw-r--r--.  1 root root  100 Dec 28  2013 .cshrc
-rw-r--r--.  1 root root  129 Dec 28  2013 .tcshrc
</code></pre>
<p>细心的同学，应该会注意到两个特殊的目录。 <code>.</code> 和 <code>..</code> 。前者表示的是当前目录，而后者表示的是上层目录。 </p>
<p>使用 <code>cd</code> 命令，将在这些目录中，自由穿梭。 </p>
<p>小技巧：如果你对英文日期阅读困难，可以使用 <code>ls -al --full-time</code> 查看可读的日期。 </p>
<h2><a class="header" href="#54切换目录" id="54切换目录">5.4、切换目录</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/26VBnyY.png!web" alt="img" /></p>
<p>执行cd命令，可以将工作目录切换到目标文件夹。为了展示cd命令的效果。请在root用户下，执行下面的命令，这将创建一个7层的目录。</p>
<pre><code>cd
mkdir -p a1/b2/c3/d4/e5/f6/{g7,g8,g9,g10}
</code></pre>
<p>我们使用cd命令，切换到最后一层。然后，我们使用 <code>..</code> 切换到上层目录。 </p>
<pre><code>[root@localhost ~]# cd a1/b2/c3/d4/e5/f6/g7
[root@localhost g7]# pwd
/root/a1/b2/c3/d4/e5/f6/g7

[root@localhost g7]# cd ..
[root@localhost f6]# pwd
/root/a1/b2/c3/d4/e5/f6
</code></pre>
<p>所以，切换到上面n层目录，只需使用多层级的 <code>../</code> 即可。有几个特殊的变量，需要说明一下。 </p>
<ul>
<li><code>../</code> 指的是上层目录 </li>
<li><code>../../</code> 指的是上两层目录 </li>
<li><code>./</code> 指的是当前目录 </li>
<li><code>~</code> 指的是当前的用户目录，这是一个缩写符号 </li>
<li><code>-</code> 使用它，可以在最近两次的目录中来回切换 </li>
</ul>
<p>我们来使用命令把上面这些特殊变量验证一下。</p>
<pre><code># 跳转到用户根目录
[root@localhost tmp]# cd ~
[root@localhost ~]# pwd
/root

# 进入到第三层目录
[root@localhost ~]# cd a1/b2/c3/
[root@localhost c3]# pwd
/root/a1/b2/c3

# 跳回到前三层目录
[root@localhost c3]# cd ../../..
[root@localhost ~]# pwd
/root

# 跳到上次访问的目录
[root@localhost ~]# cd -
/root/a1/b2/c3
[root@localhost c3]# pwd
/root/a1/b2/c3

# 进入当前目录：等于什么都没干
[root@localhost c3]# cd ./
[root@localhost c3]# pwd
/root/a1/b2/c3
</code></pre>
<p>以上就是cd命令的常用用法。现在，我们返回头来看一下 <code>mkdir</code> 。顾名思义，就是创建目录的意思，但一般在工作中，都会加上 <code>-p</code> 参数，这样就可以一次性创建多层目录。注意mkdir后面的大括号 <code>{}</code> ，可以一次性的指定多个目录进行创建，这通常能节省很多时间。 </p>
<h2><a class="header" href="#55文件操作" id="55文件操作">5.5、文件操作</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/EZFj6vy.png!web" alt="img" /></p>
<p>使用命令行操作文件，是非常方便的。</p>
<ul>
<li><code>touch</code> 新建文件 </li>
<li><code>cp</code> 复制文件 </li>
<li><code>mv</code> 移动文件 </li>
<li><code>rm</code> 删除文件 </li>
</ul>
<p>这四个风骚的命令，主宰着文件资料的去向。我们依然使用上面创建的目录，进行接下来的操作。</p>
<pre><code># 创建三个文件
[root@localhost ~]# touch long-long-long.txt
[root@localhost ~]# touch 996.txt
[root@localhost ~]# touch icu.txt
[root@localhost ~]# ls
996.txt  a1  anaconda-ks.cfg  icu.txt  long-long-long.txt

# 复制一个文件
[root@localhost ~]# cp 996.txt 007.txt
[root@localhost ~]# mv long-long-long.txt short.txt
[root@localhost ~]# ls
007.txt  996.txt  a1  anaconda-ks.cfg  icu.txt  short.txt

# 移动996.txt到a1目录，icu.txt到a1/b2目录
# 删除short.txt
[root@localhost ~]# mv 996.txt a1/
[root@localhost ~]# mv icu.txt a1/b2/
[root@localhost ~]# rm short.txt
rm: remove regular empty file ‘short.txt’? y

# 递归删除a1目录
[root@localhost ~]# rm -rvf a1/
removed directory: ‘a1/b2/c3/d4/e5/f6/g7’
removed directory: ‘a1/b2/c3/d4/e5/f6/g8’
removed directory: ‘a1/b2/c3/d4/e5/f6/g9’
removed directory: ‘a1/b2/c3/d4/e5/f6/g10’
removed directory: ‘a1/b2/c3/d4/e5/f6’
removed directory: ‘a1/b2/c3/d4/e5’
removed directory: ‘a1/b2/c3/d4’
removed directory: ‘a1/b2/c3’
removed ‘a1/b2/icu.txt’
removed directory: ‘a1/b2’
removed ‘a1/996.txt’
removed directory: ‘a1/’

[root@localhost ~]# ls
007.txt   anaconda-ks.cfg
</code></pre>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/RBb2aaj.png!web" alt="img" /></p>
<p>经过一番操作以后，只剩下了007了。除了上面基本的操作，接下来我要介绍一些更加重要的功能。</p>
<p>可以看到在使用 <code>rm</code> 删除文件的时候，进行了一次提示。这是为了避免误删除一些东西，但有时候，你需要不显示这种提示，就可以加 <code>-f</code> 参数。 <code>f</code> 参数对于cp、mv等命令来说，同样适用，它是 <code>force</code> 的意思。 </p>
<pre><code>rm -f file
cp -f file1 file2
mv -f file1 file2
</code></pre>
<p>另外，还有一个参数 <code>-r</code> ，这是递归的意思。我们的目录和文件，通常有多个层次，递归可以把操作全部作用于上面，比如上面的递归删除a1目录。 </p>
<pre><code># 警告：以下命令会造成严重后果
rm -rf /
</code></pre>
<p>上面的这个命令，你一定经常看到。这不是笑话，已经有很多用户因此丢失了数据，这就是传说中的 <code>删根</code> ，最终你将一无所有。那参数 <code>v</code> 又是干什么用的呢？加上它之后，可以看到命令详细的执行过程。在平常的操作中，我一般都加上。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/FRBjYjY.png!web" alt="img" /></p>
<h2><a class="header" href="#6开始操作文件" id="6开始操作文件">6.开始操作文件</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/6nENRfF.png!web" alt="img" /></p>
<p>你可能已经了解到， <code>ll -l</code> 命令的第一列，能够显示linux的文件类型。请对此有一个大体的印象，因为后面的很多命令，会用到这些知识。 </p>
<ul>
<li><code>-</code> 表示普通文件 </li>
<li><code>d</code> 表示目录文件 </li>
<li><code>l</code> 表示链接文件，比如快捷方式 </li>
<li><code>s</code> 套接字文件 </li>
<li><code>c</code> 字符设备文件，比如 <code>/dev/</code> 中的很多文件 </li>
<li><code>b</code> 表示块设备文件，比如一些磁盘 </li>
<li><code>p</code> 管道文件 </li>
</ul>
<p>Linux上的文件可以没有后缀，而且可以创建一些违背直觉的文件。比如后缀是png，但它却是一个压缩文件（通常不会这么做）。大学时，就有聪明的同学这样藏小电影，效果很好。</p>
<p>查看文件的具体类型，可以使用 <code>file</code> 命令，它很聪明，能够识别很多文件格式。 </p>
<pre><code>[root@localhost ~]# file /etc
/etc: directory
[root@localhost ~]# file /etc/group
/etc/group: ASCII text
[root@localhost ~]# file /dev/log
/dev/log: socket
[root@localhost ~]# file /dev/log
/dev/log: socket
[root@localhost ~]# file /bin
/bin: symbolic link to `usr/bin'
</code></pre>
<p>本部分的操作，面向的就是 <code>ASCII text</code> 类型的，普通文本文件。接下来，我们要创建一些文件。然后写入一些内容到文件里，以便进行后续的操作。 </p>
<h2><a class="header" href="#61创建一个文件" id="61创建一个文件">6.1、创建一个文件</a></h2>
<h3><a class="header" href="#611数字序列" id="611数字序列">6.1.1、数字序列</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/YjeyayM.png!web" alt="img" /></p>
<p>使用重定向符，能够直接生成文件。下面，我要生成10到20的数字，每一个数字单独一行，写入一个叫做 <code>spring</code> 的文件。巧的很， <code>seq</code> 命令可以完成这个过程。 </p>
<pre><code>seq 10 20 &gt;&gt; spring
</code></pre>
<p>我们在前面提到过 <code>&gt;</code> 的意思，是将前面命令的输出，重定向到其他地方。在这里，我们用了两个 <code>&gt;</code> ，它依然是重定向的意思，但表示的是，在原来文件的基础上， <code>追加</code> 内容。 </p>
<p>也就是编程语言里的 <code>w+</code> 和 <code>a+</code> 的意思。 </p>
<h3><a class="header" href="#612查看内容" id="612查看内容">6.1.2、查看内容</a></h3>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/AR7nI3v.png!web" alt="img" /></p>
<p>为了查看文件的生成效果，可以使用cat命令检测。cat命令将会把文件的内容，输出打印到终端上。如果加上参数 <code>n</code> ，甚至可以打印行号。效果如下： </p>
<pre><code>[root@localhost ~]# cat spring
10
11
12
13
14
15
16
17
18
19
20
[root@localhost ~]# cat -n spring
1 10
2 11
3 12
4 13
5 14
6 15
7 16
8 17
9 18
10 19
11 20
</code></pre>
<p>除了查看文件内容，cat命令通常用在更多的地方。只有和其他命令联合起来，它才会觉得生活有意义。</p>
<pre><code># 合并a文件和b文件到c文件
cat a  b&gt;&gt; c

# 把a文件的内容作为输入，使用管道处理。我们在后面介绍
cat a | cmd

# 写入内容到指定文件。在shell脚本中非常常用。我们在后面会多次用到这种写法
cat &gt; index.html &lt;&lt;EOF
&lt;html&gt;
    &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
EOF
</code></pre>
<p>由于我们的文件不大，cat命令没有什么危害。但假如文件有几个 <code>GB</code> ，使用cat就危险的多，这只叫做 <code>猫</code> 的小命令，会在终端上疯狂的进行输出，你可以通过多次按 <code>ctrl+c</code> 来终止它。 </p>
<h2><a class="header" href="#62平和的查看文件" id="62平和的查看文件">6.2、平和的查看文件</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/ZRJRNbM.png!web" alt="img" /></p>
<p>既然cat命令不适合操作大文件，那一定有替换的方案。less和more就是。由于less的加载速度比more快一些，所以现在一般都使用 <code>less</code> 。它最主要的用途，是用来分页浏览文件内容，并提供一些快速查找的方式。less是一个 <code>交互式</code> 的命令，你需要使用一些快捷键来控制它。 </p>
<p>这次我们使用seq生成 <code>一千万</code> 行记录，足足有 <code>76MB</code> 大小，然后用less打开它。 </p>
<pre><code>[root@localhost ~]# seq 10000000 &gt; spring
[root@localhost ~]# du -h spring
76M spring
[root@localhost ~]# less spring
</code></pre>
<p>关于less，一般操作如下：</p>
<ul>
<li><code>空格</code> 向下滚屏翻页 </li>
<li><code>b</code> 向上滚屏翻页 </li>
<li><code>/</code> 进入查找模式，比如 <code>/1111</code> 将查找1111字样 </li>
<li><code>q</code> 退出less </li>
<li><code>g</code> 到开头 </li>
<li><code>G</code> 去结尾 </li>
<li><code>j</code> 向下滚动 </li>
<li><code>k</code> 向上滚动，这两个按键和vim的作用非常像 </li>
</ul>
<h2><a class="header" href="#63文件头尾" id="63文件头尾">6.3、文件头尾</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/IZbARn.png!web" alt="img" /></p>
<p>head可以显示文件头，tail可以显示文件尾。它们都可以通过参数 <code>-n</code> ，来指定相应的行数。 </p>
<pre><code>[root@localhost ~]# head -n 3 spring
1
2
3
[root@localhost ~]# tail -n 3 spring
9999998
9999999
10000000
</code></pre>
<p>对于部分程序员来说， <code>tail -f</code> 或许是最常用的命令之一。它可以在控制终端，实时监控文件的变化，来看一些滚动日志。比如查看nginx或者tomcat日志等等。通常情况下，日志滚动的过快，依然会造成一些困扰，需要配合grep命令达到过滤效果。 </p>
<pre><code># 滚动查看系统日志
tail -f /var/log/messages

# 滚动查看包含info字样的日志信息
tail -f /var/log/messages | grep info
</code></pre>
<p>对于tail命令来说，还有一个大写的参数 <code>F</code> 。这个参数，能够监控到重新创建的文件。比如像一些log4j等日志是按天滚动的， <code>tail -f</code> 无法监控到这种变化。 </p>
<h2><a class="header" href="#64查找文件" id="64查找文件">6.4、查找文件</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/VjYzIrU.png!web" alt="img" /></p>
<p>考虑下面这个场景。我们需要找一个叫做 <code>decorator.py</code> 的文件，这个文件是个幽灵，可能存在于系统的任何地方。 <code>find</code> 命令，能够胜任这次捉鬼行动。 </p>
<p>我们使用 <code>find</code> 命令，从根目录找起，由于系统的文件过多，下面的命令可能会花费一段时间。 </p>
<pre><code>[root@localhost site-packages]# find / -name decorator.py  -type f
/usr/lib/python2.7/site-packages/decorator.py
</code></pre>
<p>使用time命令，可以看到具体的执行时间。执行还是挺快的么！秒出！</p>
<pre><code>[root@localhost site-packages]# time find / -name decorator.py  -type f
/usr/lib/python2.7/site-packages/decorator.py

real 0m0.228s
user 0m0.098s
sys 0m0.111s
</code></pre>
<p>find命令会查出一个路径的集合。通常是查询出来之后，进行额外的处理操作，一般配合 <code>xargs</code> 命令使用（xargs读取输入，然后逐行处理），至于find的 <code>exec</code> 参数？忘了它吧，不好用！ </p>
<pre><code># 删除当前目录中的所有class文件
find . | grep .class$ | xargs rm -rvf

# 找到/root下一天前访问的文件，type后面的类型参见文章开头
find /root  -atime 1 -type f

# 查找10分钟内更新过的文件
find /root  -cmin  -10

# 找到归属于root用户的文件
find /root -user root

# 找到大于1MB的文件，进行清理
find /root -size  +1024k  -type f | xargs rm -f
</code></pre>
<p>find的参数非常非常多，记不住怎么办？除了常用的，其实都可以通过 <code>man</code> 命令查看。man的操作也和vi非常的类似，输入 <code>/EXAMPLES</code> ，会看到很多样例。不过我觉得还是上面列出的这些命令更加的适用。 </p>
<h3><a class="header" href="#641数据来源" id="641数据来源">6.4.1、数据来源</a></h3>
<p>在上图中，你会看到mtime,ctime,atime类似的字样，它们的数据来自于何处呢？接下来我们顺理成章的看一下 <code>stat</code> 命令。 </p>
<pre><code>[root@localhost ~]# stat spring
  File: ‘spring’
  Size: 78888897   Blocks: 154080     IO Block: 4096   regular file
Device: fd00h/64768d Inode: 8409203     Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:admin_home_t:s0
Access: 2019-11-04 18:01:46.698635718 -0500
Modify: 2019-11-04 17:59:38.823458157 -0500
Change: 2019-11-04 17:59:38.823458157 -0500
 Birth: -
</code></pre>
<p>这不就是文件属性么？从文件大小，到文件类型，甚至到最后修改、访问时间，都可以从这里获取。Linux文件系统以块为单位存储信息，为了找到某一个文件所在存储空间的位置，会用 <code>i节点</code> (inode) 对每个文件进行索引，你可以认为它是一个文件指针。 </p>
<ul>
<li>
<p>文件的字节数</p>
</li>
<li>
<p>文件拥有者user</p>
</li>
<li>
<p>文件所属组group</p>
</li>
<li>
<p>文件的读、写、执行权限</p>
</li>
<li>
<p>文件的时间戳</p>
</li>
<li>
<ul>
<li>ctime指inode上一次变动的时间</li>
<li>mtime指文件内容上一次变动的时间</li>
<li>atime指文件上一次打开的时间。</li>
</ul>
</li>
<li>
<p>链接数，即有多少文件名指向这个inode （ln命令）</p>
</li>
<li>
<p>文件数据block的位置（具体的数据位置）</p>
</li>
</ul>
<p>关于inode是一个比较大的话题，也是比较重要的知识点，有兴趣的可以自行搜索。我们只需要知道这些信息是从这里来的就可以了。</p>
<h3><a class="header" href="#642小练习" id="642小练习">6.4.2、小练习</a></h3>
<p>如果我只想获取 <code>Modify</code> 这个数值，可以组合使用一下上面学到的命令。首先获取最后三行，然后获取首行。效果如下： </p>
<pre><code>[root@localhost ~]# stat spring | tail -n 3 | head -n 1
Modify: 2019-11-04 17:59:38.823458157 -0500
</code></pre>
<p>下面几个命令，效果是与上面等价的，输出结果也是一模一样。正所谓条条大路通罗马，接下来，我们首先介绍一下出现频率较高的 <code>grep</code> 。另外，我们在上面的这些命令中，多次使用了 <code>|</code> ，这是Linux中非常重要的管道概念，下面也会着重介绍。 </p>
<pre><code>stat spring | head -n 7 | tail -n 1
stat spring | grep Modify
stat spring | sed -n '7p'
stat spring | awk 'NR==7'
</code></pre>
<h2><a class="header" href="#65字符串匹配" id="65字符串匹配">6.5、字符串匹配</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/qqUrUn3.png!web" alt="img" /></p>
<p>grep用来对内容进行过滤，带上 <code>--color</code> 参数，可以在支持的终端可以打印彩色，参数 <code>n</code> 则用来输出具体的行数，用来快速定位。这是一个必须要熟练使用的命令。 </p>
<p>比如：查看nginx日志中的POST请求。</p>
<pre><code>grep -rn --color POST access.log
</code></pre>
<p>推荐每次都使用这样的参数。</p>
<p>如果我想要看某个异常前后相关的内容，就可以使用ABC参数。它们是几个单词的缩写，经常被使用。</p>
<ul>
<li>A  after  内容后n行</li>
<li>B  before  内容前n行</li>
<li>C  内容前后n行</li>
</ul>
<p>就像是这样：</p>
<pre><code># 查看Exception关键字的前2行和后10行
grep -rn --color Exception -A10 -B2   error.log

#查找/usr/下所有import关键字，已经它们所在的文件和行数
grep -rn --color import /usr/
</code></pre>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/UjiUVv6.gif!web" alt="img" /></p>
<h2><a class="header" href="#66管道" id="66管道">6.6、管道</a></h2>
<p>在上面的命令中，我们多次用到了 <code>|</code> ，这貌似可以完成一些神奇的事情。 <code>|</code> 是 <code>pipe</code> 的意思，它可以把多个命令联系起来。通常，命令有下面的关联方式： </p>
<ul>
<li><code>;</code> 顺序执行，如 <code>mkdir a;rmdir a</code></li>
<li><code>&amp;&amp;</code> 条件执行，如 <code>mkdir a &amp;&amp; rmdir a</code></li>
<li><code>||</code> 条件执行，如 <code>mkdir a || rmdir a</code> ，后面的命令将不执行 </li>
<li><code>|</code> 管道，前面命令的输出，将作为后面命令的输入 </li>
</ul>
<p>前三种的命令关联，是非常简单有逻辑的，非常的好理解。而管道，却有自己的特点。</p>
<p>接触过编程语言的都知道 <code>stdin</code> 、 <code>stdout</code> 、 <code>stderr</code> 的概念。让我们重新组织一下针对于管道的定义：前面命令的输出(stdin)，将作为后面命令的输入(stdout)。 </p>
<p>我们拿一行命令来说明。</p>
<pre><code>seq 20 100 | head -n 50 | tail -n 1
</code></pre>
<p>上面命令，将输出69。69是个神奇的数字，它是怎么办到的呢？我们来一张小图，一切就豁然开朗了。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/VBV7rmi.png!web" alt="img" /></p>
<p>关于输入输出和错误，linux使用一个 <code>数字</code> 进行缩写，这在一些脚本中，甚至在一些安装文件中，会经常用到。 </p>
<ul>
<li>0 表示stdin标准输入</li>
<li>1 表示stdout标准输出</li>
<li>2 表示stderr标准错误</li>
</ul>
<p>通过类似 <code>2&gt;&amp;1</code> 的语法，可以把错误信息定向到标准输出。我们用命令来证明一下。 </p>
<pre><code># 错误信息无法输出到文件
[root@localhost ~]# cat aaaaaaaaa &gt; b
cat: aaaaaaaaa: No such file or directory
[root@localhost ~]# cat b

# 错误信息被重定向了
[root@localhost ~]# cat aaaaaaaaa &gt; b 2&gt;&amp;1
[root@localhost ~]# cat b
cat: aaaaaaaaa: No such file or directory
</code></pre>
<h2><a class="header" href="#67排序" id="67排序">6.7、排序</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/EnmE3yu.png!web" alt="img" /></p>
<p>在了解管道的工作原理之后，就可以介绍一下sort命令了。它通常可以和uniq（去重）命令联合，完成一些排序、去重的操作。首先使用cat命令，生成如下内容的文件。 </p>
<pre><code>cat &gt; sort.txt &lt;&lt;EOF
1 11
3 22
2 44
4 33
5 55
6 66
6 66
EOF
​```bash
接下来让这两个命令上台表演一下。sort可以使用-t指定分隔符，使用-k指定要排序的列。但是空格，是不需要做这些画蛇添足的指定的。
​```bash
# 根据第一列倒序排序
[root@localhost ~]# cat sort.txt | sort  -n -k1 -r
6 66
6 66
5 55
4 33
3 22
2 44
1 11

# 统计每一行出现的次数，并根据出现次数倒序排序
# 此时，行数由7变成了6
[root@localhost ~]# cat sort.txt | sort  | uniq -c  | sort -n -k1 -r
2 6 66
1 5 55
1 4 33
1 3 22
1 2 44
1 1 11
</code></pre>
<p>注意：uniq命令，一般用在已经经过排序的结果集上。所以，很多情况需要首先使用sort命令进行排序后，再使用uniq命令。新手经常会忘记第一步，造成命令不能正常运行。</p>
<h2><a class="header" href="#68小练习" id="68小练习">6.8、小练习</a></h2>
<p>本部分，我们从文件的属性开始说起，了解了几个对文件操作的常用命令。并顺便介绍了管道的概念。下面，我们来练习一下。</p>
<h4><a class="header" href="#找到系统中所有的-grubcfg-文件并输出它的行数" id="找到系统中所有的-grubcfg-文件并输出它的行数">找到系统中所有的 <code>grub.cfg</code> 文件，并输出它的行数。</a></h4>
<p>分析：首先需要使用find命令，找到这些文件。然后使用xargs逐行处理。最后，使用wc命令，统计确切的行数。</p>
<pre><code>[root@localhost grub2]# find / | grep grub.cfg | xargs wc -l
141 /boot/grub2/grub.cfg
</code></pre>
<h4><a class="header" href="#输出系统的group列表" id="输出系统的group列表">输出系统的group列表</a></h4>
<pre><code>cat /etc/group | awk -F ':' '{print $1}'
</code></pre>
<h4><a class="header" href="#下面这个命令输出nginx日志的ip和每个ip的pvpv最高的前10" id="下面这个命令输出nginx日志的ip和每个ip的pvpv最高的前10">下面这个命令输出nginx日志的ip和每个ip的pv，pv最高的前10</a></h4>
<pre><code># 2019-06-26T10:01:57+08:00|nginx001.server.ops.pro.dc|100.116.222.80|10.31.150.232:41021|0.014|0.011|0.000|200|200|273|-|/visit|sign=91CD1988CE8B313B8A0454A4BBE930DF|-|-|http|POST|112.4.238.213

awk -F&quot;|&quot; '{print $3}' access.log | sort | uniq -c | sort -nk1 -r | head -n10
</code></pre>
<h2><a class="header" href="#69思考扩展" id="69思考扩展">6.9、思考&amp;扩展</a></h2>
<p>1、Linux的终端，是如何实现彩色的文字的？我要如何输出一个绿色的 <code>Hello World</code> ? </p>
<p>2、软链接与硬链接有什么区别？</p>
<p>3、了解几个偏门但又不是非常偏的命令。</p>
<ul>
<li><code>cut</code> 有了awk，几乎不怎么会用cut了 </li>
<li>tr</li>
<li>col</li>
<li>paste</li>
<li>join</li>
<li>split</li>
</ul>
<h2><a class="header" href="#7-正则和高级用法" id="7-正则和高级用法">7. 正则和高级用法</a></h2>
<p>你可能遇到一些棘手的问题，通过搜索得到想要的结果，但下次还是要通过搜索解决问题，这种低效的手段不是我们所想要的。典型的就是一个线上运维工程师，当问题来临时，不会给你留太多的 <code>现场学习</code> 时间。 </p>
<p>为了达到更高效的训练，我们要做两件事情：第一，总结归纳；第二，触类旁通。Linux的命令也是如此，一个问题，通常会有多种解决方式，要通过变化找出其中的共性。</p>
<p>这涉及到一些设计者对于规范约定俗成的遵守。一般的，你只需要掌握一小部分命令，然后对大批命令达到了解的程度，就可以在命令行的世界里游刃有余。举个例子，你知道 <code>ls</code> 是列出文件目录，你就会联想到 <code>lscpu</code> 是列出cpu信息； <code>lsmem</code> 是列出内存信息; <code>lsblk</code> 是磁盘信息等。这种共性很多，比如 <code>top</code> 系列， <code>stat</code> 系列。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/ue2UNnb.png!web" alt="img" /></p>
<h2><a class="header" href="#71辅助信息" id="71辅助信息">7.1、辅助信息</a></h2>
<h3><a class="header" href="#711linux文件格式" id="711linux文件格式">7.1.1、Linux文件格式</a></h3>
<p>在Linux上工作，是非常非常排斥二进制这种格式的，几乎什么都是可以读写的文本内容。大多数命令生成的结果，也都是文本文件。这些文件有一些特点，通常列与列都是通过空格或者 <code>&lt;TAB&gt;</code> 键分隔的。比如下面 <code>lsmem</code> 的结果，这种有规律的，有章可循的文件，是非常容易被处理的。 </p>
<pre><code>[root@localhost ~]# lsmem  
RANGE                                  SIZE  STATE REMOVABLE BLOCK
0x0000000000000000-0x0000000007ffffff  128M online        no     0
0x0000000008000000-0x000000000fffffff  128M online       yes     1
0x0000000010000000-0x0000000017ffffff  128M online        no     2
0x0000000018000000-0x0000000027ffffff  256M online       yes   3-4
0x0000000028000000-0x000000004fffffff  640M online        no   5-9
0x0000000050000000-0x000000005fffffff  256M online       yes 10-11
0x0000000060000000-0x000000007fffffff  512M online        no 12-15

Memory block size:       128M
Total online memory:       2G
Total offline memory:      0B
</code></pre>
<p>有一大批针对于行操作的命令，同样有一批针对于列操作的命令。然后，有两个集大成者，叫做 <code>sed</code> 、 <code>awk</code> 。由于这两个命令的内容非常多，我们将其列为单独的章节。 </p>
<h3><a class="header" href="#712命令记不住怎么办" id="712命令记不住怎么办">7.1.2、命令记不住怎么办？</a></h3>
<p>通常linux命令都十分简单，但是有些还是有些复杂度的。比如 <code>find</code> ， <code>ps</code> 这种命令，如果要照顾到所有的场合，可能需要非常巨大的篇幅。但是，万一用到这种偏门的场合怎么办？ </p>
<p>全面了解一下是非常有必要的，以便在使用的时候能够唤起记忆中最浅显的印象。然后剩下的，就可以交给类似于 <code>man</code> 的这种命令了。Linux上的每一个命令，都会有配套的帮助文件，这远比网络上那些转来转去的信息，正确的多。 </p>
<p>正式介绍一下下面的两个命令：</p>
<ul>
<li><code>man</code> 用来显示某个命令的文档信息。比如： <code>man ls</code></li>
<li><code>info</code> 你可以认为和man是一样的，虽然有一些能够互补的内容。它们会在内容中进行提示的 </li>
<li><code>--help</code> 很多命令通过参数 <code>--help</code> 提供非常简短的帮助信息。这通常是最有用最快捷的用例展示。如果你根本就记不住一个非常拗口的单词，那就找找这些地方吧 </li>
</ul>
<p>注意：这些帮助信息，仅集中在命令的作用域本身。对于它的组合使用场景，并没有过多信息。也就是说，它教会了你怎么用，但并没有告诉你用它能够来做什么。</p>
<p>这些帮助命令，一般会通过高亮关键字，增加阅读的体验。但我们可以更近一步，把帮助文件变成彩色的。在root用户下，执行下面的命令。然后， <strong>重新登录虚拟机</strong> 。 </p>
<pre><code>cat &gt;&gt; ~/.bashrc &lt;&lt;EOF
function man()
{
    env \\
    LESS_TERMCAP_mb=\$(printf &quot;\e[1;31m&quot;) \\
    LESS_TERMCAP_md=\$(printf &quot;\e[1;31m&quot;) \\
    LESS_TERMCAP_me=\$(printf &quot;\e[0m&quot;) \\
    LESS_TERMCAP_se=\$(printf &quot;\e[0m&quot;) \\
    LESS_TERMCAP_so=\$(printf &quot;\e[1;44;33m&quot;) \\
    LESS_TERMCAP_ue=\$(printf &quot;\e[0m&quot;) \\
    LESS_TERMCAP_us=\$(printf &quot;\e[1;32m&quot;) \\
    man &quot;\$@&quot;
}
EOF
</code></pre>
<p>再次执行man命令，就可以看到彩色的信息了。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/MzIFNry.png!web" alt="img" /></p>
<h3><a class="header" href="#713tab补全" id="713tab补全">7.1.3、TAB补全</a></h3>
<p>现在，在终端里，输入 <code>ca</code> ，然后快速按2次 <code>&lt;TAB&gt;</code> 键盘，命令行会进入补全模式，显示以ca打头的所有命令。 </p>
<pre><code>[root@localhost ~]# ca
cacertdir_rehash     cache_dump           cache_repair         cache_writeback      ca-legacy            capsh                case                 catchsegv
cache_check          cache_metadata_size  cache_restore        cal                  caller               captoinfo            cat                  catman
</code></pre>
<p>如果你对某个命令，只有模糊的印象，只记得前面的几个字母，这个功能是极好的，命令范围会一步步缩减。</p>
<h2><a class="header" href="#72正则表达式" id="72正则表达式">7.2、正则表达式</a></h2>
<p>为了开始下面的内容，我们首先介绍一下正则表达式。在前面的一些命令中，也可以使用这些正则表达式，比如less、grep等。</p>
<p>有些书籍，能够把正则表达式写成一本书，我们这里仅作简单的介绍，但足够用了。一般的，正则表达式能用在匹配上，还能够把匹配的内容拿来做二次利用。关于后者，我们在 <code>sed</code> 命令中介绍。 </p>
<table><thead><tr><th align="left">标志</th><th align="left">意义</th></tr></thead><tbody>
<tr><td align="left"><code>^</code></td><td align="left">行首</td></tr>
<tr><td align="left"><code>$</code></td><td align="left">行尾</td></tr>
<tr><td align="left"><code>.</code></td><td align="left">任意单个字符</td></tr>
<tr><td align="left"><code>*</code></td><td align="left">匹配0个或者多个前面的字符</td></tr>
<tr><td align="left"><code>+</code></td><td align="left">1个或者多个匹配</td></tr>
<tr><td align="left"><code>?</code></td><td align="left">0个或者1个匹配</td></tr>
<tr><td align="left"><code>{m}</code></td><td align="left">前面的匹配重复m次</td></tr>
<tr><td align="left"><code>{m,n}</code></td><td align="left">前面的匹配重复m到n次</td></tr>
<tr><td align="left"><code>[]</code></td><td align="left">匹配一个指定范围内的字符</td></tr>
<tr><td align="left"><code>[^]</code></td><td align="left">匹配指定范围外的任意单个字符</td></tr>
<tr><td align="left"><code>\</code></td><td align="left">转义字符</td></tr>
<tr><td align="left"><code>[0-9]</code></td><td align="left">匹配括号中的任何一个字符,or的作用</td></tr>
<tr><td align="left">`</td><td align="left">`</td></tr>
<tr><td align="left"><code>\b</code></td><td align="left">匹配一个单词。比如 <code>\blucky\b</code> 只匹配单词lucky</td></tr>
</tbody></table>
<p>使用下面的命令创建一个文件，我们练习一下grep命令加上 <code>E</code> 参数后的正则表现。 </p>
<pre><code>cat &gt; 996 &lt;&lt;EOF
996: 996 is a funcking thing . which make woman as man , man as ass .
we all on the bus , bus bus on the way . 996
way to icu. icuuuuuu......
The greedy green boss rides on the pity programmer
EOF
</code></pre>
<p>在终端执行下面命令，注意高亮的部分即为匹配到的字符串。</p>
<pre><code># 匹配996开头的行
[root@localhost ~]# cat 996 | grep -E ^996
996: 996 is a funcking thing . which make woman as man , man as ass .

# 匹配996结尾的行
[root@localhost ~]# cat 996 | grep -E 996$
we all on the bus , bus bus on the way . 996

# 匹配到icu和icuuuuuu
[root@localhost ~]# cat 996 | grep -E icu+
way to icu. icuuuuuu......

# 再次匹配到996
[root@localhost ~]# cat 996 | grep -E [0-9]
996: 996 is a funcking thing . which make woman as man , man as ass .
we all on the bus , bus bus on the way . 996

[root@localhost ~]# cat 996 | grep -E ^[\^0-9]
we all on the bus , bus bus on the way . 996
way to icu. icuuuuuu......
The greedy green boss rides on the pity programmer

# 匹配所有不包含996的行，良心命令，泪奔
[root@localhost ~]# cat 996 | grep -E -v [0-9]{3}
way to icu. icuuuuuu......
The greedy green boss rides on the pity programmer

# 匹配boss和icu
[root@localhost ~]# cat 996 | grep -E boss\|icu
way to icu. icuuuuuu......
The greedy green boss rides on the pity programmer

# 匹配所有行
[root@localhost ~]# cat 996 | grep -E .
996: 996 is a funcking thing . which make woman as man , man as ass .
we all on the bus , bus bus on the way . 996
way to icu. icuuuuuu......
The greedy green boss rides on the pity programmer
</code></pre>
<p>正则表达式非常的重要，在一些sed脚本中，awk脚本中，甚至是vim编辑器中，都会简化你的操作。以上内容应该熟记，达到不需要查找文档的地步。</p>
<p>下面有6个小问题，可以思考一下。</p>
<p>1、回过头去，执行一下 <code>man cat</code> ，是否发现了一个叫做 <code>tac</code> 的命令？它是干什么的？ </p>
<p>2、上面提到的 <code>stat</code> 系列，你能想象 <code>iostat</code> 大体是干什么用的么？ </p>
<p>3、 <code>grep -v</code> 是什么意思？ </p>
<p>4、了解一下和mv非常像的 <code>rename</code> 命令来批量修改文件，看能否使用上面的正则。 </p>
<p>5、有些命令如果拼写错误，如何快速修正？靠搜索么？了解一下 <code>fuck</code> 命令。我没有说错。 </p>
<p>6、下面哪种写法表示如果cmd1成功执行，则执行cmd2命令？</p>
<ul>
<li>A. cmd1&amp;&amp;cmd2</li>
<li>B. cmd1|cmd2</li>
<li>C. cmd1;cmd2</li>
<li>D. cmd1||cmd2</li>
</ul>
<h2><a class="header" href="#8-linux下的压缩" id="8-linux下的压缩">8. Linux下的压缩</a></h2>
<p>压缩，是一件非常神奇的事情。</p>
<p>很久很久之前，就接触过一些 <strong>64KB</strong> 大小的电影，你花 <strong>半小时</strong> 都看不完。事实上，这些动画的真实容量是 <strong>15GB</strong> ，Warez组织把它压缩了 <strong>25万倍</strong> 。 </p>
<p>你要是Windows系统，可以在这里下载体验一下。但我们现在讲的是Linux，很打脸是不是？</p>
<pre><code>链接: https://pan.baidu.com/s/12YJQ4jsbtRr7RxoLpARTyQ 
提取码: r7sp
</code></pre>
<p>压缩是件神奇的事。它能大能小，能伸能缩，在现实中很难找到这样的东西。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/baeiem.png!web" alt="img" /></p>
<p>为了减小传输文件的大小，或者为了传输方便，一般都会开启压缩。linux下常见的压缩文件有tar、bzip2、zip、rar等，7z这种用的相对较少。压缩之后的文件，非常适合在网络环境上传输。甚至，你可以认为iso文件为一种特殊的压缩方式。 </p>
<p><code>.tar</code> 使用tar命令压缩或解压 <code>.bz2</code> 使用bzip2命令操作 <code>.gz</code> 使用gzip命令操作 <code>.zip</code> 使用unzip命令解压 <code>.rar</code> 使用unrar命令解压 <code>.Z</code> 使用compress,uncompress </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/uAbi6rI.png!web" alt="img" /></p>
<p>准备工作：使用下面的命令，复制1000个文件。 </p>
<pre><code>cd ~
mkdir files
cd files
seq 1000 | xargs -I {} cp  /etc/group  {}
</code></pre>
<p>使用ls，就可以看到我们刚才创建的1000个文件。接下来，我们使用压缩命令将它打包成一个。</p>
<pre><code># 查看1000个文件的总大小
[root@localhost files]# du -h .
4.0M .

# 切换到root目录
cd ~

# 使用tar进行压缩，压缩后的文件不到1MB
[root@localhost ~]# tar cvf files.tar files

[root@localhost ~]# du -h files.tar
1012K files.tar

# 使用gizp提高压缩比，压缩后的文件只有12KB
[root@localhost ~]# gzip files.tar
[root@localhost ~]# du -h files.tar.gz
12K files.tar.gz
</code></pre>
<p>tar和gzip一般是联合使用的。tar命令提供了一种特殊的功能，就是可以在打包解包的同时调用其他的压缩程序，比如：gzip，bzip2等。</p>
<p>下面的命令，与上面执行两次命令后是等同的。所以，一般使用下面的方式进行操作。</p>
<pre><code>[root@localhost ~]# tar cvfz files2.tar.gz files
[root@localhost ~]# du -h files2.tar.gz
12K files2.tar.gz
</code></pre>
<p>与之对应的，就是解压操作。我们只需要改动命令行中的一个字母即可： <code>c</code> -&gt; <code>x</code> 。但其实，参数 <code>v</code> 和 <code>z</code> 也是可以省略的。 </p>
<pre><code>[root@localhost ~]# tar xvfz files2.tar.gz
</code></pre>
<p>我们更加常用的方式，是加上参数 <code>C</code> ，指定一个要解压的目录。比如下面的命令，把压缩内容解压到/opt目录中。 </p>
<pre><code>[root@localhost ~]# tar xvfz files2.tar.gz -C /opt/
</code></pre>
<p>那如果我仅仅想要看下压缩文件中包含哪些文件呢？这就要使用参数 <code>t</code> 。 </p>
<ul>
<li><code>c</code> 压缩 </li>
<li><code>x</code> 解压 </li>
<li><code>t</code> 查看列表 </li>
</ul>
<h4><a class="header" href="#安装其他的" id="安装其他的">安装其他的</a></h4>
<p>我们来看一下常用的zip和rar解压程序有没有安装。</p>
<pre><code>[root@localhost ~]# which unzip
/usr/bin/which: no unzip in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)
[root@localhost ~]# which unrar
/usr/bin/which: no unrar in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)
</code></pre>
<p>所以，我们的系统并没有安装这两个应用。那我就使用centos的包管理工具 <code>yum</code> 安装一下。java中的jar命令也是与zip类似的，可自行探索。 </p>
<pre><code>[root@localhost ~]# yum install -y zip unzip rar unrar
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.tuna.tsinghua.edu.cn
 * updates: mirrors.aliyun.com
...
</code></pre>
<p>rar不能安装成功，所以rar文件并不能被解压。没关系，我们在后面的章节把它安装上。</p>
<p>现在，你会在Linux安装tomcat了么？</p>
<p>接下来，我们思考一下：</p>
<p>1、 经过zip压缩的文件，再使用gzip压缩，容量还会减少么？</p>
<p>为了验证这个过程，可以使用 <code>dd</code> 命令，生成一个 <code>69MB</code> 大小的随机文件。 <code>dd</code> 命令也是个神奇哦。 </p>
<pre><code>[root@localhost ~]# dd if=/dev/urandom  of=test bs=1M count=69
69+0 records in
69+0 records out
72351744 bytes (72 MB) copied, 0.446161 s, 162 MB/s


[root@localhost ~]# du -h test
69M test
</code></pre>
<p>所以，回到文章最上面，我们可以随机生成一批文件，让压缩效果更有意义一点。</p>
<pre><code>seq 1000 | xargs -i dd if=/dev/zero of={}.xjj bs=1k count=256
</code></pre>
<p>2、如果已经有了文件，tar命令是如何做到强制覆盖的？</p>
<h2><a class="header" href="#9-linux的权限体系" id="9-linux的权限体系">9. Linux的权限体系</a></h2>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/E7ZfeiQ.png!web" alt="img" /></p>
<p>我们在最最最上面，刚接触命令行的时候，就使用 <code>chmod</code> 命令，给普通文本文件，赋予了执行权限。本小节将看一下 <code>用户权限</code> 和 <code>文件权限</code> 这两个息息相关的概念， </p>
<h2><a class="header" href="#91添加用户" id="91添加用户">9.1、添加用户</a></h2>
<p>到现在为止，我们的系统中，还孤零零的只有这一个用户，是时候学学女娲，捏几个小泥人了。</p>
<p>首先创建两个用户：张三（zhang3）、李四（li4）。</p>
<pre><code>[root@localhost ~]# useradd zhang3
</code></pre>
<p>查看下面命令的三个输出结果。</p>
<pre><code># 系统中多了一个叫做zhang3的组，group文件保存了系统的组信息
[root@localhost ~]# tail -n1 /etc/group
zhang3:x:1000:

# 系统中多了一个叫做zhang3的用户，shadow文件保存了它们的密码。很多安全渗透就是为了拿到它进行暴力破解
[root@localhost ~]# tail -n1 /etc/shadow
zhang3:!!:18207:0:99999:7:::

# home目录中，多了一个叫做zhang3的目录
[root@localhost ~]# ll /home --full-time
total 0
drwx------. 2 zhang3 zhang3 83 2019-11-06 22:09:33.357165082 -0500 zhang3
</code></pre>
<p>接下来，给我们刚刚建立的用户，使用 <code>passwd</code> 设置一个密码。密码需要输入两次进行确认。如果想要更改密码，可以使用 <code>chpasswd</code> 命令。 </p>
<pre><code>[root@localhost ~]# passwd zhang3
Changing password for user zhang3.
New password:
BAD PASSWORD: The password is shorter than 8 characters
Retype new password:
passwd: all authentication tokens updated successfully.
</code></pre>
<p>那么如何删除一个现有的用户呢？这是通过 <code>userdel</code> 命令实现的。加上参数 <code>f</code> ，会在其他用户使用系统的时候，强制退出。 </p>
<pre><code>userdel -f zhang3
</code></pre>
<h2><a class="header" href="#92文件权限说明" id="92文件权限说明">9.2、文件权限说明</a></h2>
<p>从上面的命令执行结果中，我们发现了有两件非常有意思的东西。添加用户后，除了在密码文件 <code>shadow</code> 中增加了一些内容，同时还在 <code>group</code> 文件中添加了信息。这涉及到用户的两个属性：用户名，组名。 </p>
<p>一个用户只有一个名称代号，但是可以有多个组。下面命令创建一个密码为123的用户 <code>li4</code> ，并给它追加一个叫做 <code>zhang3</code> 的组。可以看到 <code>/etc/group</code> 文件中的信息变更。 </p>
<pre><code>[root@localhost ~]# useradd  -G zhang3 -p 123 li4
[root@localhost ~]# tail -n 2 /etc/group
zhang3:x:1000:li4
li4:x:1001:
</code></pre>
<p>好啦，接下来切换到我们的文件权限上面。为了进行下面命令的验证，我们首先创建一个名字叫 <code>confirm777.sh</code> 的脚本文件。为了让脚本对所有用户可见，我们把它创建在/tmp目录下。 </p>
<pre><code>cat &gt; /tmp/confirm777.sh &lt;&lt;EOF
echo $USER
id
EOF
</code></pre>
<p>使用 <code>ll</code> 命令查看文件信息。 </p>
<pre><code>[root@localhost ~]# ll /tmp/confirm777.sh --full-time
-rw-r--r--. 1 root root 13 2019-11-07 04:25:55.418254935 -0500 confirm777.sh
</code></pre>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/IzuuUjz.png!web" alt="img" /></p>
<p>从 <code>ll</code> 的命令可以看出，文件的所有者是root用户，文件所属的组，也是root组，它的权限是 <code>rw-r--r--</code> 。文件权限分为三部分。 </p>
<ul>
<li>
<pre><code>所有者权限
u
rw-
</code></pre>
</li>
<li>
<pre><code>组用户权限
g
r--
</code></pre>
</li>
<li>
<pre><code>其他用户权限
o
r--
</code></pre>
</li>
<li>
<p><code>全部</code> ，缩写为 <code>a</code> ，表示对上面三类用户集体操作。 </p>
</li>
</ul>
<p>那rw-这些东西是什么意思呢？</p>
<ul>
<li><code>r</code> 表示可读权限。read。 </li>
<li><code>w</code> 表示可写权限。write。 </li>
<li><code>x</code> 表示可执行权限。execute。 </li>
<li><code>-</code> 权限占位符，表示没有当前权限。 </li>
</ul>
<p>注意：一个用户拥有文件的w权限，并不代表就可以删除文件。w仅仅针对于文件内容来说的。</p>
<p>一个文件，有3类用户，每类用户，有3种权限。使用最简单的小学乘法，我们能够得出，一个文件的权限位，需要 <code>3x3=9</code> 个标志位表示。 </p>
<p>我们的文件名称，叫做confirm777.sh，这个名字是随便起的么？当然不是， <code>777</code> 在linux代表特殊的含义，它代表文件对所有用户具有可读、可写、可执行的权限。可以想象，如果每个文件都有这样的权限，系统将无安全可言。那这一串数字是怎么来的呢？可以看下面的对照表。 </p>
<ul>
<li><code>r</code> <code>4</code> 读 </li>
<li><code>w</code> <code>2</code> 写 </li>
<li><code>x</code> <code>1</code> 执行 </li>
</ul>
<p>对以上三个属性进行任意组合，可以得到：</p>
<ul>
<li><code>4</code> <code>r--</code> 4+0+0 </li>
<li><code>6</code> <code>rw-</code> 4+2+0 </li>
<li><code>5</code> <code>r-x</code> 4+0+1 </li>
<li><code>2</code> <code>-w-</code> 0+2+0 </li>
<li><code>3</code> <code>-wx</code> 0+2+1 </li>
<li><code>1</code> <code>--x</code> 0+0+1 </li>
<li><code>7</code> <code>rwx</code> 4+2+1 </li>
</ul>
<h2><a class="header" href="#93文件权限更改" id="93文件权限更改">9.3、文件权限更改</a></h2>
<p>下面介绍三个文件权限相关的命令。一般常用的，就是chown和chmod。</p>
<p><code>chown</code> 更改文件的所有者。 <code>chgrp</code> 更改文件的组。 <code>chmod</code> 更改文件权限。 </p>
<p>接下来，我们把 <code>confirm777.sh</code> 的所有者和组，修改成刚刚创建的用户 <code>zhang3</code> 。 </p>
<pre><code>cd /tmp
[root@localhost tmp]# chown zhang3:zhang3 confirm777.sh
[root@localhost tmp]# ll confirm777.sh
-rw-r--r--. 1 zhang3 zhang3 13 Nov  7 04:25 confirm777.sh
</code></pre>
<p>给文件所有者增加执行权限。然后分别切换到 <code>zhang3</code> ， <code>li4</code> 用户执行一下。 </p>
<p>通过 <code>su</code> 命令，可以切换到其他用户，一般使用 <code>su -</code> 进行环境变量的清理；而命令 <code>id</code> ，能够看到当前正在执行的用户信息。 </p>
<pre><code>[root@localhost tmp]# chmod u+x confirm777.sh
[root@localhost tmp]# su li4
[li4@localhost tmp]$ ./confirm777.sh
bash: ./confirm777.sh: Permission denied
[li4@localhost tmp]$ exit
exit

[root@localhost tmp]# su zhang3
[zhang3@localhost tmp]$ ./confirm777.sh
root
uid=1000(zhang3) gid=1000(zhang3) groups=1000(zhang3) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
</code></pre>
<p>可以看到，文件所有者zhang3可以执行文件，但不相关的li4，提示没有权限。接下来，我们验证用户组相关的权限位。</p>
<pre><code># 去掉zhang3的执行权限
root@localhost tmp]# chmod u-x confirm777.sh
[root@localhost tmp]# ll confirm777.sh
-rw-r--r--. 1 zhang3 zhang3 13 Nov  7 04:25 confirm777.sh

# 增加zhang3组的执行权限，由于li4在zhang3组里，它拥有权限
[root@localhost tmp]# chmod g+x confirm777.sh
[root@localhost tmp]# ll confirm777.sh
-rw-r-xr--. 1 zhang3 zhang3 13 Nov  7 04:25 confirm777.sh

# 切换到zhang3进行执行
[root@localhost tmp]# su - zhang3
[zhang3@localhost tmp]$ ./confirm777.sh
bash: ./confirm777.sh: Permission denied
[zhang3@localhost tmp]$ exit
exit

# 切换到li4进行执行
[root@localhost tmp]# su - li4
[li4@localhost tmp]$ ./confirm777.sh
root
uid=1001(li4) gid=1001(li4) groups=1001(li4),1000(zhang3) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
</code></pre>
<p>从命令的执行结果可以看出。这次，li4能够执行文件，相反的，zhang3却不能。</p>
<p>我们使用chmod命令来修改文件权限，使用的是类似于 <code>a+x</code> 这样的英文字母。拿第一个脚本来说，初始的权限是 <code>rw-r--r--</code> ，也就是 <code>644</code> ，在这种情况下，下面的两个脚本等效。 </p>
<pre><code>chmod u+x confirm777.sh
chmod 744 confirm777.sh
</code></pre>
<p>可以看到，第二个命令，使用的是数字样式的权限位，多了一步人脑转换过程。这在日常的使用中，是非常不方便的。所以，使用符号法的表示方式，能够更加直观，非常推荐。</p>
<p>为了更直观的表现这个过程，我专门制作了一张图。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/BzEbaaU.png!web" alt="img" /></p>
<h2><a class="header" href="#94目录权限" id="94目录权限">9.4、目录权限</a></h2>
<p>这里有一个非常有意思的地方。把文件设置成可执行，可以把普通文件变成脚本，目录文件的可执行权限是什么鬼？有什么意义？对文件夹来说：</p>
<ul>
<li><code>r</code> 表示允许读取目录中的文件名，但不能进入该目录 </li>
<li><code>w</code> 表示允许用户修改目录，可以创建、迁移、删除、更名目录下的文件 </li>
<li><code>x</code> 可以获得目录下文件的列表，以及进入目录，执行cd命令 </li>
</ul>
<p>关于r和x的区别，可以看下面的命令结果，仔细感受一下它们的区别。一般的，几乎所有的目录，都拥有 <code>执行</code> 权限，不要随意对其进行设置。 </p>
<pre><code>[root@localhost tmp]# su - li4
[li4@localhost ~]$ cd /tmp

[li4@localhost tmp]$ mkdir nox
[li4@localhost tmp]$ touch nox/{a,b,c,d}
[li4@localhost tmp]$ chmod a-x nox
[li4@localhost tmp]$ ls nox
ls: cannot access nox/a: Permission denied
ls: cannot access nox/b: Permission denied
ls: cannot access nox/c: Permission denied
ls: cannot access nox/d: Permission denied
a  b  c  d
[li4@localhost tmp]$ cat nox/a
cat: nox/a: Permission denied

[li4@localhost tmp]$ chmod a+x nox
[li4@localhost tmp]$ chmod a-r nox
[li4@localhost tmp]$ ls nox
ls: cannot open directory nox: Permission denied
</code></pre>
<h2><a class="header" href="#95sticky-bit" id="95sticky-bit">9.5、sticky bit</a></h2>
<p>接下来，我们介绍一个比较烧脑的粘贴位。</p>
<p>假如你要删除一个文件，你可以没有这个文件的写权限，但是你必须要拥有这个文件上级目录的写权限。如何创建一个目录，可以让任何人些人文件，但是又不能删除其他用户的文件？这就是stick bit的作用。粘贴位一般只用于目录上，对文件来说并没有什么用处。粘贴位一般使用 <code>t</code> 表示。 </p>
<p>我们可以看一个典型的目录 <code>/tmp</code></p>
<pre><code>[root@localhost tmp]#  ls -dl /tmp
drwxrwxrwt. 9 root root 4096 Nov  7 06:27 /tmp
</code></pre>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/7R7JRr2.png!web" alt="img" /></p>
<p>可以看到，最后一位，显示的是t，而不是x，意思是普通用户不能删除其他用户的文件。所有用户在/tmp目录中，都可以随意创建文件，但是却删除不了其他人的文件，即使文件的权限是 <code>777</code> 。 </p>
<pre><code>[root@localhost tmp]# touch /tmp/stick
[root@localhost tmp]# chown li4:li4 /tmp/stick
[root@localhost tmp]# chmod 777 /tmp/stick
[root@localhost tmp]# su - zhang3
[zhang3@localhost ~]$ rm /tmp/stick
rm: cannot remove ‘/tmp/stick’: Operation not permitted
</code></pre>
<p>我们在上面创建了两个用户zhang3和li4，并拿它们测试了chown和chmod命令，最后介绍了粘贴位。linux比较安全的原因，就是因为有比较详尽的权限划分。但权限是枚双刃剑，超权用户一个命令就可以搞垮系统，许多隐藏的木马，通过提权运行在不为人知的地方。</p>
<p>权限相关的几个命令会经常被使用，下面举几个例子。</p>
<pre><code># 设置/var/lib/mysql的用户和组为mysql
chown -R mysql:mysql /var/lib/mysql

# 设置目录可读可写，能够上传文件
chmod  777 /var/www/uploads

# 增加本目录下所有sh的执行权限
chomd a+x *.sh

# 变更file为可读可写可执行
chmod u=rwx,g=rwx,o=rwx file
</code></pre>
<p>下面依然是思考时间：</p>
<p>1、下面这个命令，执行以后，会发生什么情况？警告：不要执行，哪怕把000改成其他数字。</p>
<pre><code># R遍历子目录的意思
chmod -R 000 /
</code></pre>
<p>2、有一天，我看到一个命令 <code>chmod u+s file</code> ，文中并没有介绍 <code>s</code> 是什么意思，这是什么意思？ </p>
<p>3、如何删除一个用户的组？</p>
<h2><a class="header" href="#10-如何对磁盘进行操作" id="10-如何对磁盘进行操作">10. 如何对磁盘进行操作？</a></h2>
<p>下面的场景非常的恐怖，对有些程序员来说可以是一场噩梦。</p>
<p>一大早刚刚去上班，煎饼果子刚啃了一半，几个全副武装的警察就闯进了公司。二话不说控制住了工作人员，并守株待兔的等着鱼儿来上班。</p>
<p>原因就是：公司涉嫌存储和扩散非法文件，需要查封所有的服务器进行彻查。</p>
<p>这些文件，有的简单的放在磁盘上，有的放在文件存储服务器上，有的，被切成了多片放在了不同的廉价机器上。</p>
<p>接下来会发生什么，要看技术人员的水平，但估计结果并不会太好。</p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/uAZVbiq.png!web" alt="img" /></p>
<p>在上一小节，我们创建了两个普通用户，这两个用户没什么本事，和默认的用户 <code>root</code> 比起来，它们的权限就小得多。除了自己目录下的文件，其他的，它几乎都没有权限去修改。 </p>
<p>这些文件，肯定是要存在磁盘上的。对磁盘的管理，有非常多的命令，这一小节的内容，对于系统管理员来说，经常使用；但对于开发来说，就要求比较低一些。因为开发只需要知道小电影存在什么地方了，不需要知道小电影是怎么存的。</p>
<p>那定罪的时候，运维和程序员，到底是谁的锅更大一些？其实是个悖论。运维人员在发呆的时候，脑子里回忆起了下面的知识。</p>
<h2><a class="header" href="#101添加新硬盘" id="101添加新硬盘">10.1.添加新硬盘</a></h2>
<p>你要是一个系统管理员，甚至是一个上了云的系统管理员，现在买了一块 <code>aws</code> 的扩展盘，它是不能被使用的。需要经过格式化挂载以后，才能投入生产。 </p>
<p>还记得在安装系统的时候么？其中有一步，需要对虚拟机的磁盘，进行划分，我们直接采用默认的方式。不过现在已经改不了了，它已经是过去式了。</p>
<p>为了模拟对磁盘的管理，我们需要首先给虚拟机新加一块虚拟磁盘。首先，使用 <code>shutdown -h now</code> 命令关闭机器，进行下面的操作。 </p>
<p>1、进入settings选项，然后切换到storage，添加磁盘 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/JBva6vy.png!web" alt="img" /></p>
<p>2、点击创建一块磁盘 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/jyqmayr.png!web" alt="img" /></p>
<p>3、选择VDI </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/MJNBN3u.png!web" alt="img" /></p>
<p>4、动态扩容，用多少扩多少 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/MJNBN3u-20210225103430074.png!web" alt="img" /></p>
<p>5、我们创建一块2GB大的，叫做disk2的磁盘 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/beEvyyJ.png!web" alt="img" /></p>
<p>启动机器。远程连接192的ip，别忘了执行 <code>dhclient</code> 命令。 </p>
<p>首先使用 <code>fdisk</code> 看一下目前的磁盘状况。 </p>
<pre><code>root@localhost ~]# fdisk -l

Disk /dev/sda: 8589 MB, 8589934592 bytes, 16777216 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000c2410

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200    16777215     7339008   8e  Linux LVM

Disk /dev/sdb: 2147 MB, 2147483648 bytes, 4194304 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/centos-root: 6652 MB, 6652166144 bytes, 12992512 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/centos-swap: 859 MB, 859832320 bytes, 1679360 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
</code></pre>
<p>从命令的结果，我们看到了有两块磁盘。 <code>/dev/sda</code> 和 <code>/dev/sdb</code> ，其中 <code>sda</code> 已经被分配，已经被我们的文件系统所占用。现在，回忆一下 <code>/dev</code> 目录的用途，在这个目录下，存放了一些设备文件，假如我们再添加一块磁盘，它的句柄就应该是 <code>sdc</code> (sd*)。 </p>
<p>在这整块磁盘能够被使用之前，我们需要对它进行三次操作。</p>
<ol>
<li>磁盘分区</li>
<li>磁盘格式化</li>
<li>磁盘挂载</li>
</ol>
<h2><a class="header" href="#102分区" id="102分区">10.2.分区</a></h2>
<p>对磁盘分区依然是 <code>fdisk</code> 命令，以下命令，将进入交互模式。在交互模式中，输入 <code>n</code> 新建分区。由于我们的磁盘只有2GB，所以只创建一个分区就好。根据向导，一路确定向下，最后，输入 <code>w</code> 确定写入分区表，同时退出命令交互。 </p>
<p>再次执行 <code>fdisk -l</code> ，可以看到已经多了一块 <code>2gb</code> 大小的分区。 </p>
<pre><code>[root@localhost ~]# fdisk /dev/sdb
...
[root@localhost ~]# fdisk -l
...
   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4194303     2096128   83  Linux
...
</code></pre>
<h2><a class="header" href="#103格式化" id="103格式化">10.3.格式化</a></h2>
<p>在命令行，输入 <code>mkfs</code> ，然后按 <code>&lt;TAB&gt;</code> 进行补全，将会显示一批命令。 </p>
<pre><code>[root@localhost ~]# mkfs.
mkfs.btrfs   mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.ext4    mkfs.minix   mkfs.xfs
</code></pre>
<p>这批命令，都可以对磁盘进行格式化。目前，最常用的磁盘格式是 <code>ext4</code> 。但我们并没有找到windows操作系统的 <code>FAT</code> 以及 <code>NTFS</code> 等格式，但它们在概念上是等同的。 </p>
<p><img src="way-api-wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8OS/linux%E5%9F%BA%E7%A1%80.assets/7niU7nf.png!web" alt="img" /></p>
<p>下面介绍一下Linux下常用的磁盘格式。 </p>
<ul>
<li><code>btrfs</code> GPL授权。是为了替换ext系统而发起的。不熟悉，不过多评价。 </li>
<li><code>cramfs</code> 门针对闪存设计的只读压缩的文件系统，其容量上限为256M,采用zlib压缩，很少用 </li>
<li><code>ext2</code> ext的早先版本。 </li>
<li><code>ext3</code> ext2的改进。 </li>
<li><code>ext4</code> 使用最多。如果对其他的不熟悉，老老实实用ext4吧。 </li>
<li><code>minix</code> 比较古老，也不常用。 </li>
<li><code>xfs</code> XFS 文件系统是扩展文件系统的一个扩展，是 64 位高性能日志文件系统。centos7.0开始的默认文件系统。 </li>
</ul>
<p>我们就录乡随俗，将磁盘给格式化成xfs。</p>
<pre><code>[root@localhost ~]# mkfs.xfs /dev/sdb1
</code></pre>
<p>注意：如果想要把磁盘格式化成 <code>fat32</code> 的格式，需要安装一个软件。 </p>
<pre><code> yum install dosfstools -y
</code></pre>
<h2><a class="header" href="#104挂载" id="104挂载">10.4.挂载</a></h2>
<p>最后一步，是使用 <code>mount</code> 命令挂载磁盘。我们把它挂载到 <code>/data</code> 目录。 </p>
<p><code>df</code> 命令能够看到系统的磁盘使用状况，参数 <code>h</code> 是 <code>human</code> 的意思，以比较容易读的方式展现信息； <code>lsblk</code> 则以另一个角度查看系统磁盘挂载情况。 </p>
<pre><code>[root@localhost ~]# mkdir /data
[root@localhost ~]# mount /dev/sdb1 /data
[root@localhost ~]# df -h
Filesystem               Size  Used Avail Use% Mounted on
devtmpfs                 908M     0  908M   0% /dev
tmpfs                    920M     0  920M   0% /dev/shm
tmpfs                    920M  8.6M  911M   1% /run
tmpfs                    920M     0  920M   0% /sys/fs/cgroup
/dev/mapper/centos-root  6.2G  1.4G  4.9G  22% /
/dev/sda1               1014M  149M  866M  15% /boot
tmpfs                    184M     0  184M   0% /run/user/0
/dev/sdb1                2.0G   33M  2.0G   2% /data

root@localhost ~]# lsblk  -f
NAME            FSTYPE      LABEL UUID                                   MOUNTPOINT
sda
├─sda1          xfs               ac3a3ce8-6ab1-4c0b-91c8-b4e617f0dfb4   /boot
└─sda2          LVM2_member       3GzmOd-TUc1-p2ZN-wT5q-ttky-to9l-PF495o
  ├─centos-root xfs               9f86f663-060a-4450-90f9-3005ad9c5d92   /
  └─centos-swap swap              cf8709b0-b0ab-4d44-a23e-ad76f85efad6   [SWAP]
sdb
└─sdb1          xfs               0a7c861c-1a31-45b3-bf37-c72229f35704   /data
</code></pre>
<p>为了能够在开机的时候加载磁盘，我们需要修改 <code>/etc/fstab</code> 文件。这种文件修改的时候一定要小心，否则会造成系统无法启动。 </p>
<pre><code>[root@localhost ~]# echo &quot;/dev/sdb1  xfs defaults 0 0&quot; &gt;&gt; /etc/fstab
[root@localhost ~]# cat /etc/fstab
/dev/mapper/centos-root / xfs defaults        0 0
UUID=ac3a3ce8-6ab1-4c0b-91c8-b4e617f0dfb4 /boot  xfs     defaults        0 0
/dev/mapper/centos-swap swap    swap    defaults        0 0
/dev/sdb1                       xfs     defaults        0 0
</code></pre>
<h2><a class="header" href="#105交换分区" id="105交换分区">10.5.交换分区</a></h2>
<p>由于内存的容量有限，现在的操作系统，都会使用磁盘模拟一个 <code>虚拟内存</code> 区域，用于缓冲一些数据。由于磁盘的速度和内存不可同日而语，通常会造成应用程序的卡顿。卡归卡，应用进程却可以因此苟延残喘，续命。 </p>
<p><code>swap</code> 分区，即交换区，系统在物理内存不够时，与 <code>swap</code> 进行交换。即当系统的物理内存不够用时，把硬盘中一部分空间释放出来，以供当前运行的程序使用。当那些程序要运行时，再从 <code>swap</code> 分区中恢复保存的数据到内存中。 </p>
<p>现代互联网公司，一般对接口的响应时间有比较高的要求， <code>swap</code> 分区一般是禁用的。关于 <code>swap</code> ，有下面几个相关的命令。 </p>
<pre><code># 制作交换分区
[root@localhost ~]# mkswap /dev/sdb1

# 禁用所有交换分区
[root@localhost ~]# swapoff -a

# 启用交换分区
[root@localhost ~]# swapon
</code></pre>
<h2><a class="header" href="#106-使用dd命令进行备份" id="106-使用dd命令进行备份">10.6 使用dd命令进行备份</a></h2>
<p>下面的命令，将直接备份磁盘A到磁盘B。</p>
<pre><code># dd if=/dev/sda of=/dev/sdb
</code></pre>
<p>在上面的命令中， <code>if</code> 代表输入的文件， <code>of</code> 代表输出的文件。根据Linux下一切皆文件的原理，这里的文件指的就是设备。 </p>
<p><code>dd</code> 命令还可以将整个磁盘打包成一个镜像文件。比如下面的命令。 </p>
<pre><code># dd if=/dev/hda of=~/hdadisk.img
</code></pre>
<p>当然，恢复磁盘的时候，也是相当简单的，我们只需要逆向操作就可以了。</p>
<pre><code># dd if=hdadisk.img of=/dev/hda
</code></pre>
<h2><a class="header" href="#end" id="end">End</a></h2>
<p>这篇文章有6万字，经历了多个版本的整理，有小伙伴已经拿着它作为了公司的培训资料。到现在为止，你已经对Linux的命令行有了比较客观的了解。但我这里还有很多可以让你更上一层楼的文章，比如vim、sed、awk的使用。下面是几个扩展阅读，同样采用xjjdog专用的命令行三段解析法，希望对你有所帮助。</p>
<p><code>最常用</code> 系列，快速掌握三贱客↓ </p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650518612&amp;idx=1&amp;sn=125c2cb9ee6d76a6817fb0ebc5a3c5e4&amp;scene=21#wechat_redirect">最常用的一套“Vim“技巧</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519751&amp;idx=1&amp;sn=adef39cb108277731608069960692c77&amp;chksm=8780bf03b0f73615adbb3da1fcbd342be465cc80ec6cb06a412714e474748003c3ff319e02e5&amp;scene=21#wechat_redirect">最常用的一套“Sed“技巧</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519843&amp;idx=1&amp;sn=fe4a5c405a35b42a850054eb4283ff40&amp;chksm=8780bee7b0f737f194d356c155b67d19be574454adcb8ce0d16c84e6246a718c9cf29c223512&amp;scene=21#wechat_redirect">最常用的一套“AWK“技巧</a></p>
<h4><a class="header" href="#荒岛余生系列" id="荒岛余生系列">荒岛余生系列</a></h4>
<p><code>荒岛余生</code> 系列，快速掌握故障排查↓ </p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519137&amp;idx=1&amp;sn=8922471455cef842b1acbd24db405bca&amp;scene=21#wechat_redirect">Linux之《荒岛余生》（一）准备篇</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519172&amp;idx=1&amp;sn=e8cade4652e257e8836f52e71d6d9a68&amp;scene=21#wechat_redirect">Linux之《荒岛余生》（二）CPU篇</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519204&amp;idx=1&amp;sn=b367c1987fb8c985e83a6cb90f5436a6&amp;scene=21#wechat_redirect">Linux之《荒岛余生》（三）内存篇</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519238&amp;idx=1&amp;sn=7a479485c3ea7b8d61f101ceefdab05b&amp;scene=21#wechat_redirect">Linux之《荒岛余生》（四）I/O篇</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519279&amp;idx=1&amp;sn=dcb57c5e7d303383280984f40d6dc356&amp;scene=21#wechat_redirect">Linux之《荒岛余生》（五）网络篇</a></p>
<p>欢迎加我的好友xjjdog0，一块入群增加buff值。</p>
<p>作者简介： <strong>小姐姐味道</strong> (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。 </p>
<p>加我好友，一起起飞吧。 </p>
<p><img src="https://img0.tuicool.com/IJf6zmE.png!web" alt="img" /></p>
<blockquote>
<p>alpine docker</p>
</blockquote>
<h2><a class="header" href="#请求rust镜像" id="请求rust镜像">请求rust镜像</a></h2>
<pre><code class="language-shell">&gt; docker pull rust:alpine
</code></pre>
<h2><a class="header" href="#加入国内cargo镜像源" id="加入国内cargo镜像源">加入国内cargo镜像源</a></h2>
<pre><code class="language-shell">&gt; vi cargo_temp_config
# 写入
[source.crates-io]
replace-with='ustc'

[source.ustc]
registry=&quot;https://mirrors.ustc.edu.cn/crates.io-index&quot;

&gt; docker run -it -v ./cargo_temp_config:/.cargo/config rust:alpine 
# ⚠️此处如果使用$HOME/.cargo/config将不起作用
</code></pre>
<h3><a class="header" href="#dockerfile" id="dockerfile">dockerfile</a></h3>
<pre><code class="language-dockerfile"># 重新制作一个新的docker image
FROM rust:alpine
# 修改alpine源为ustc
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories
# 避免cargo编译时出现问题
ENV CARGO_HTTP_MULTIPLEXING false
# 加入cargo国内源的配置文件
RUN mkdir /.cargo
ADD ./cargo_temp_config /.cargo/config
</code></pre>
<p>执行命令<code>docker build -t rust_alpine .</code>构建镜像</p>
<h3><a class="header" href="#多阶段构建镜像" id="多阶段构建镜像">多阶段构建镜像</a></h3>
<pre><code class="language-dockerfile">FROM rust:alpine as builder
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories
ENV CARGO_HTTP_MULTIPLEXING false
RUN mkdir /.cargo
ADD ./cargo_temp_config /.cargo/config
RUN apk add git
RUN git clone https://xxx.xxx.xxx/xxx/xxx # 改为自己的仓库地址
RUN cd xxx
RUN cargo build --release

FROM rust:alpine
COPY --from=builder /build_source/target/release/xxx .
CMD [&quot;./xxx&quot;]
</code></pre>
<p>执行命令<code>docker build -t rust_alpine .</code>构建镜像</p>
<h2><a class="header" href="#cargo-install编译中出现的问题" id="cargo-install编译中出现的问题">cargo install编译中出现的问题</a></h2>
<table><thead><tr><th align="left">问题</th><th>解决</th></tr></thead><tbody>
<tr><td align="left">= note: /usr/lib/gcc/x86_64-alpine-linux-musl/9.3.0/../../../../x86_64-alpine-linux-musl/bin/ld: cannot find crti.o: No such file or directory<br/>          collect2: error: ld returned 1 exit status</td><td>apk add --no-cache -U musl-dev</td></tr>
</tbody></table>
<h2><a class="header" href="#克隆源代码" id="克隆源代码">克隆源代码</a></h2>
<pre><code class="language-shell">&gt; apk add git
# Git安装完成

&gt; git clone https://xxx...
</code></pre>
<h2><a class="header" href="#crontab-error-renaming解决办法" id="crontab-error-renaming解决办法">crontab: error renaming解决办法</a></h2>
<blockquote>
<p>因为挖矿病毒，某些文件加入了chattr +i权限</p>
</blockquote>
<p>执行 crontab -e 命令，系统显示类似如下。</p>
<pre><code class="language-shell">[root@iZkZ cron]# crontab -e
crontab: installing new crontab
crontab: error renaming /var/spool/cron/#tmp.xx.XXXX3tTwiC to /var/spool/cron/root
rename: Operation not permitted
crontab: edits left in /tmp/crontab.BRY7dw
</code></pre>
<p>解决方法：进入<code>cd /var/spool/cron</code>，执行命令<code>chattr -i root</code>，修改/var/spool/cron/root权限。
然后执行<code>crontab -e</code>命令，系统显示类似如下，表示恢复正常。
crontab: installing new crontab</p>
<p>执行完，再将权限改回来<code>chattr +i root</code></p>
<p>原文链接：https://blog.csdn.net/qq_29485643/java/article/details/89072025</p>
<h2><a class="header" href="#centos7-修改密码不需要重启" id="centos7-修改密码不需要重启">CentOS7 修改密码，不需要重启</a></h2>
<h4><a class="header" href="#修改密码" id="修改密码">修改密码</a></h4>
<pre><code class="language-shell"># 输入passwd，再输入两次新密码后，立即生效
&gt; passwd
</code></pre>
<h2><a class="header" href="#centos7定时任务" id="centos7定时任务">CentOS7定时任务</a></h2>
<p>cron服务是Linux的内置服务，但它不会开机自动启动，可以每分钟执行任务。可以用以下命令启动和停止服务：</p>
<pre><code class="language-shell">systemctl start crond
systemctl stop crond
systemctl restart crond
systemctl reload crond
systemctl status crond
</code></pre>
<p>添加开机启动</p>
<pre><code class="language-shell">vi /etc/rc.local

/bin/systemctl start crond.service
</code></pre>
<p><strong>crontab操作</strong></p>
<pre><code class="language-shell">crontab -u //设定某个用户的cron服务 
crontab -l //列出某个用户cron服务的详细内容 
crontab -r //删除某个用户的cron服务 
crontab -e //编辑某个用户的cron服务
crontab -i //打印提示，输入yes等确认信息

/var/spool/cron/root (以用户命名的文件) 是所有默认存放定时任务的文件
/etc/cron.deny 该文件中所列出用户不允许使用crontab命令
/etc/cron.allow 该文件中所列出用户允许使用crontab命令，且优先级高于/etc/cron.deny

/var/log/cron    该文件存放cron服务的日志
</code></pre>
<p><strong>基本格式</strong></p>
<pre><code class="language-shell"># For details see man 4 crontabs
# Example of job definition:
# .---------------- minute (0 - 59)
# | .------------- hour (0 - 23)
# | | .---------- day of month (1 - 31)
# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...
# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# | | | | |
# * * * * * user-name command to be executed
定时任务的每段为：分，时，日，月，周，用户，命令
第1列表示分钟1～59 每分钟用*或者 */1表示
第2列表示小时1～23（0表示0点）
第3列表示日期1～31
第4列表示月份1～12
第5列标识号星期0～6（0表示星期天）
第6列要运行的命令

*：表示任意时间都，实际上就是“每”的意思。可以代表00-23小时或者00-12每月或者00-59分
-：表示区间，是一个范围，00 17-19 * * * cmd，就是每天17,18,19点的整点执行命令
,：是分割时段，30 3,19,21 * * * cmd，就是每天凌晨3和晚上19,21点的半点时刻执行命令
/n：表示分割，可以看成除法，*/5 * * * * cmd，每隔五分钟执行一次
</code></pre>
<p>https://www.cnblogs.com/p0st/p/9482167.html</p>
<h1><a class="header" href="#挖矿病毒清理" id="挖矿病毒清理">挖矿病毒清理</a></h1>
<blockquote>
<p>中了多次挖矿病毒，一直找不到中的原因，只能被动查找并删除。阿里云的服务器是不是有漏洞？除了系统暴露的端口之外，曾经只开了一个MySQL：3306端口，中了netflix病毒之后就关闭了。</p>
</blockquote>
<h2><a class="header" href="#第一种伪装netflix挖矿病毒" id="第一种伪装netflix挖矿病毒">第一种：伪装netflix挖矿病毒</a></h2>
<ol>
<li><code>top</code>，查看哪个进程CPU高。一般有两个<code>netflix</code>和<code>yqgnnb</code></li>
<li><code>lsof -p 进程id</code>，根据信息找出病毒目录进行删除。有一个.sazh的路径，全部删除</li>
<li>删除<code>/tmp</code>目录所有内容，有些硬炮无法删除，执行<code>lsattr</code>，如有<code>---------i------------</code>，那么执行<code>chattr -i *</code>，解除权限后，再执行删除</li>
<li><code>kill -9 netflix</code></li>
<li><code>kill -9 yqgnnb</code></li>
<li>查看<code>/var/spool/cron/root</code>是否有定时任务来启动挖矿脚本</li>
</ol>
<h2><a class="header" href="#第二种watchdogs挖矿病毒" id="第二种watchdogs挖矿病毒">第二种：watchdogs挖矿病毒</a></h2>
<blockquote>
<p>这种病毒较为常见，网上搜索有专门的解决方案和清理脚本。我只记录几个关键的命令和路径。</p>
</blockquote>
<ul>
<li>
<p><code>lsattr</code>查看当前文件夹内的程序权限。<strong>目的是找出有--------------i-------------的病毒文件</strong></p>
</li>
<li>
<p><code>chattr -i 程序名</code>解除-----------i-------------权限</p>
</li>
<li>
<p><code>/etc/rc.d/init.d</code>此目录有两个挖矿病毒<code>watchdogs</code>和<code>kthrotlds</code>，删除它</p>
</li>
<li>
<p><code>rm /usr/local/lib/libioset.so</code>删除此文件</p>
</li>
<li>
<p><code>cd /tmp</code>并<code>rm -rf *</code>删除/tmp内的文件</p>
</li>
<li>
<p>查看<code>/var/spool/cron/root</code>是否有定时任务来启动挖矿脚本</p>
<p>参考：https://www.secpulse.com/archives/99420.html</p>
</li>
</ul>
<h2><a class="header" href="#manjaro文档" id="manjaro文档">manjaro文档</a></h2>
<blockquote>
<p>本文档只为工作相关进行编写。</p>
</blockquote>
<h3><a class="header" href="#manjaro简介" id="manjaro简介">manjaro简介</a></h3>
<p>​		Manjaro是一个基于Arch Linux的开源发行版本。该软件继承了所有当前高端前沿软件的优点：不仅启动速度快，而且自动化程度高、人工干预少，但能在需要的时候提供必要的帮助。</p>
<p>​		Manjaro是一个优秀的走进Linux世界的入口。不像专用操作系统，您可以不受限制地完全控制硬件。对于那些想学习Linux的工作原理以及它与其他操作系统的不同之处的人来说，Manjaro是理想的选择。从这个角度来看，它也适合初学者。</p>
<p>​		Manjaro能通过使用兼容性软件，例如Wine或PlayonLinux轻松运行许多流行的Windows应用程序。</p>
<p>​		Manjaro不是面向消费者的操作系统。您拥有完全的控制权，可以对自己安装的程序进行破坏性的操作而系统也不会加以阻止。当然，修复这些破坏性的操作也是一种乐趣！另一方面，如果您对Manjaro的工作方式感到满意，则无需进行任何更改。</p>
<p>​		另外，对于经验丰富的Linux用户而言，Manjaro代表了理想的中间地带。他们既需要良好的性能，全面的控制和尖端的软件，又需要一定程度的软件版本稳定性。</p>
<h3><a class="header" href="#manjaro-特点" id="manjaro-特点">Manjaro 特点</a></h3>
<ul>
<li>
<p>免费 Manjaro永远完全免费。我们创建它，是为了让我们拥有一个易于使用且稳定的基于Linux的操作系统，而作为用户的您，需要知道的是我们不会失去对您的控制并尊重您的隐私。</p>
</li>
<li>
<p>资源丰富 软件中心提供了数千种软件应用程序，其中包括与流行的Windows软件（如MS Office）完全兼容的等效软件。任何软件也是完全免费的。无需在网上搜索直接安装即可。</p>
</li>
<li>
<p>社区完善 我们有一个气氛友好的论坛，在那里每个人都将会受到欢迎。该论坛是与所有人共享知识、交流Linux的合适场所。</p>
</li>
<li>
<p>可用性 Manjaro可用于64位体系结构。官方支持XFCE，KDE和Gnome版本。其它版本，包括32位体系结构的版本，是由社区维护。</p>
</li>
</ul>
<h3><a class="header" href="#manjaro-特色" id="manjaro-特色">Manjaro 特色</a></h3>
<ul>
<li>
<p>易于控制</p>
<ul>
<li>
<p>更新自由 当系统（包括软件）有更新时，系统仅提示有更新可用。系统不会自动在后台自动下载，安装和重启。</p>
</li>
<li>
<p>自由的数据安全策略 Manjaro不会将任何数据发送给任何人。您的数据只有您可以决定如何处理。</p>
</li>
<li>
<p>方便定制 Manjaro带有默认设置，我们认为它对大多数用户有用。但是，与大多数Linux发行版一样，您仍然可以选择配置，更改，删除或替换所需的任何选项。这些选项中的大多数都可以通过易于使用的配置程序直接获得。</p>
</li>
</ul>
</li>
<li>
<p>一键配置</p>
<ul>
<li>
<p>安装软件简单 Manjaro维护自己的程序（安装，更新和删除）时，只需打开它，选择所需的内容，然后单击“安装”即可。所有其他需要的软件包将自动安装，您要做的就是启动程序。</p>
</li>
<li>
<p>语言包丰富 只需在系统中启动区域设置，然后选择所需的语言即可。登出并再次登录后，一切都随您所愿。系统还提供了一种特殊的工具，可以自动为各种程序安装语言包，并翻译自己关心的程序。</p>
</li>
<li>
<p>显卡驱动安装简单 Manjaro附带MHWD（Manjaro硬件检测）。如果您需要用于硬件的驱动程序，只需打开它，单击“自动安装”，然后等待完成即可。而已。</p>
</li>
<li>
<p>切换内核简单 高级用户和需要Linux内核的特殊功能（而不是默认功能）的人员只需单击一下即可切换到其他内核。您制作音乐还是需要其他实时功能？只需切换到RT内核即可。您是否需要最新改进的开源图形驱动程序？只需切换到较新的版本即可。 Manjaro同时支持多个已安装的内核。只需重新引导系统，然后在引导菜单中进行选择即可。</p>
</li>
<li>
<p>……</p>
</li>
</ul>
</li>
<li>
<p>用户受众面广</p>
<p>Manjaro是满足您各种需求的高效伴侣。用户从家庭用户到学生和老师，从程序员和开发人员到专业人士，艺术爱好者，音乐爱好者，多媒体专业人员等等。 在这里，在大多数情况下，您所需要的软件均可通过存储库立即获得，而无需查找它们或冒潜在的恶意软件下载风险。</p>
</li>
<li>
<p>新鲜且稳定</p>
<p>Manjaro基于独立开发的Arch操作系统。在Linux社区中，Arch本身以其异常快速，强大且轻量级的发行版而闻名，该发行版可访问最新软件。但是，Arch还针对经验更丰富或技术娴熟的用户。 若最新的软件出现一些问题，例如与现有软件的不兼容性或错误的话，有经验的用户可以自己解决这些问题。但是对于没有足够专业知识的普通用户，或者对于不想弄清楚问题的来龙去脉的用户来说，就比较麻烦。 为防止出现此种问题，Manjaro 向 Arch 存储库添加了额外的测试层。普通软件包将通过这些附加层，并且只会在没有更多问题的情况下才发布给想要稳定系统的用户。</p>
</li>
</ul>
<h3><a class="header" href="#manjaro系统安装" id="manjaro系统安装">manjaro系统安装</a></h3>
<ol>
<li>进入<code>清华镜像</code>网站，查找<code>manjaro</code>关键字，找到<code>manjaro</code>系统安装iso，有三个桌面版本<code>gnome</code>、<code>kde</code>、<code>xfce</code>（有什么区别请网上搜索学习）。</li>
<li>下载manjaro xfce版本。</li>
<li>安装manjaro xfce，如果试用，使用虚拟机体验；如果真机安装，将iso写入到usb中，pc机设置usb启动。</li>
<li>安装过程简单，<code>language=zh_CN</code>，<code>boot with open source</code>，<code>timezone shanghai</code>等，最后一步到93%时会下载一些包，由于官方网络速度慢，先关闭网络（跳过此步骤），然后就会提示安装完成，（虚拟机卸掉加载的iso。真机把usb拔掉）重新启动。</li>
<li>进入安装后的操作系统，打开网络。</li>
</ol>
<h3><a class="header" href="#manjaro系统配置" id="manjaro系统配置">manjaro系统配置</a></h3>
<blockquote>
<p>具体怎么设置，网上搜即可，不复述。</p>
</blockquote>
<ol>
<li>pacman将源改成国内的。</li>
<li>将archlinuxcn配置为ustc（软件较全，速度稳定），<strong>传说中的tsinghua时不时的就没有找到软件、网速时而变得非常慢</strong>。</li>
<li>安装yay。</li>
<li>修改<code>xfce终端</code>，加入参数<code>--drop-down</code>，改为下滑式。快捷键自行定义（例如：F12）。</li>
</ol>
<h3><a class="header" href="#manjaro软件安装" id="manjaro软件安装">manjaro软件安装</a></h3>
<blockquote>
<p>软件具体什么功能，不懂的就搜索一下。软件具体安装过程，去搜索。</p>
</blockquote>
<ul>
<li>
<p>日常软件</p>
<ul>
<li><code>搜狗输入法</code>、四叶草输入法</li>
<li><code>Google Chrome</code></li>
<li><code>LibreOffice</code></li>
<li><code>Typora</code></li>
<li><code>kate</code></li>
</ul>
</li>
<li>
<p>开发IDE</p>
<ul>
<li><code>IDEA 社区版</code></li>
<li><code>Virtual Studio Code</code></li>
</ul>
</li>
<li>
<p>版本控制</p>
<ul>
<li><code>GIT</code></li>
<li><code>GitAhead</code></li>
</ul>
</li>
<li>
<p>数据库</p>
<ul>
<li><code>Navicat</code>、Dbeaver</li>
<li><code>PostgreSql</code></li>
<li>redis-desktop-manager</li>
</ul>
</li>
<li>
<p>其它</p>
<ul>
<li><code>JDK</code>（OpenJDK、Amazon Corretto ...）</li>
<li><code>Rust</code></li>
<li><code>Termius</code></li>
<li><code>FileZilla</code></li>
<li><code>Docker</code>、Podman</li>
<li><code>SwitchHosts!</code></li>
<li><code>Postman</code></li>
<li>unrar</li>
</ul>
</li>
<li>
<p>美化</p>
<ul>
<li><code>dockbarX</code>类似ubuntu左侧栏，可以将app锁定在栏内方便使用。也可以将其认为是MacOS的dock栏。</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#manjaro软件安装技巧" id="manjaro软件安装技巧">manjaro软件安装技巧</a></h4>
<blockquote>
<p>一般使用pacman或yay能完成安装，奈何有一些应用没有提供，所以需要加入额外的操作过程。</p>
</blockquote>
<ul>
<li>使用<code>pacman</code>安装🚀🚀🚀🚀🚀</li>
<li>使用<code>yay</code>安装🚀🚀🚀🚀🚀</li>
<li>单独对<code>PKGBUILD</code>文件进行编辑并执行<code>makepkg -si</code>🚀🚀🚀🚀</li>
<li>使用<code>snap</code>安装🚀🚀</li>
<li>使用<code>brew</code>安装🚀🚀</li>
</ul>
<p>mac抓包</p>
<p>#mitmproxy</p>
<blockquote>
<p>使用mitmproxy，免费</p>
</blockquote>
<h3><a class="header" href="#安装运行" id="安装运行">安装&amp;运行</a></h3>
<ol>
<li>
<p>在mac终端执行命令<code>brew install mitmproxy</code>进行安装</p>
</li>
<li>
<p>执行命令<code>mitmdump —version</code>看到如下输出，代表安装成功</p>
<pre><code class="language-shell">Mitmproxy: 4.0.4
Python:    3.7.3
OpenSSL:   OpenSSL 1.0.2r  26 Feb 2019
Platform:  Darwin-18.2.0-x86_64-i386-64bit
</code></pre>
</li>
<li>
<p>执行命令<code>mitmproxy</code>启动，默认端口为8080，如果要自定义端口<code>-p 端口号</code></p>
</li>
<li>
<p>启动完成，在要抓包的设备中设置网关内容</p>
<pre><code class="language-shell">ip: 127.0.0.1 # 改为启动mitmproxy的机器ip
port: 8080 # 默认。如果自定义就改为自定义端口
</code></pre>
</li>
</ol>
<h3><a class="header" href="#可视化页面" id="可视化页面">可视化页面</a></h3>
<blockquote>
<p>可以通过webui直观查看抓包结果</p>
</blockquote>
<ol>
<li>终端执行命令<code>mitmweb</code>，默认端口8081，修改默认端口<code>--web-port 端口号</code></li>
<li>运行成功后，浏览器弹出<code>127.0.0.1:8081</code>网页，<strong>默认的proxy端口为8080</strong></li>
</ol>
<h3><a class="header" href="#https" id="https">https</a></h3>
<blockquote>
<p>抓取https配置方式</p>
</blockquote>
<ol>
<li>首先启动mitmproxy</li>
<li>打开浏览器输入mitm.it，下载证书（在对应的设备上），关于证书的配置在页面有描述</li>
<li>证书配置完成后，重启mitmproxy即可抓取https包</li>
</ol>
<h2><a class="header" href="#macos-catalina显示read-only-file-system的对应方法" id="macos-catalina显示read-only-file-system的对应方法">MacOS (Catalina)：显示Read-only file system的对应方法</a></h2>
<p>在Catalina版的macOS上以root身份登录，发现创建类似/data之类的目录会会提示Read-only file system，这篇文章介绍一下原因和对应方法。</p>
<h3><a class="header" href="#os版本" id="os版本">OS版本</a></h3>
<pre><code class="language-shell">liumiaocn:util liumiao$ sw_vers
ProductName:	Mac OS X
ProductVersion:	10.15.2
BuildVersion:	19C57
liumiaocn:util liumiao$ 
</code></pre>
<h3><a class="header" href="#现象" id="现象">现象</a></h3>
<pre><code class="language-shell">liumiaocn:/ root# id
uid=0(root) gid=0(wheel) groups=0(wheel),1(daemon),2(kmem),3(sys),4(tty),5(operator),8(procview),9(procmod),12(everyone),20(staff),29(certusers),61(localaccounts),80(admin),701(com.apple.sharepoint.group.1),33(_appstore),98(_lpadmin),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh),400(com.apple.access_remote_ae)
liumiaocn:/ root# mkdir -p /data
mkdir: /data: Read-only file system
liumiaocn:/ root# 
</code></pre>
<h3><a class="header" href="#原因" id="原因">原因</a></h3>
<p>根据官方提示，升级至Catalina之后，硬盘会分为两部分：</p>
<ul>
<li>只读部分</li>
<li>可写部分</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200215112038738.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdW1pYW9jbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<blockquote>
<p>With macOS Catalina, you can no longer store files or data in the read-only system volume, nor can you write to the “root” directory ( / ) from the command line, such as with Terminal.</p>
</blockquote>
<p>在Catalina版本，使用者无法在只读系统卷进行数据的存储，使用root在通过命令行的方式也无法对/根目录下进行写操作了。</p>
<p>详细可参看：https://support.apple.com/en-us/HT210650</p>
<h3><a class="header" href="#对应方法" id="对应方法">对应方法</a></h3>
<p>首先设定SIP，详细可参看：https://liumiaocn.blog.csdn.net/article/details/104328486</p>
<pre><code class="language-shell">liumiaocn:~ root# csrutil status
System Integrity Protection status: disabled.
liumiaocn:~ root# mkdir -p /data
mkdir: /data: Read-only file system
liumiaocn:~ root#
</code></pre>
<p>可以看到此时仍然无法创建目录，因为/仍然是只读方式, 修改一下/使之具有write的权限可以看到即可进行操作：</p>
<pre><code class="language-shell">liumiaocn:~ root# mount -uw /
liumiaocn:~ root# mkdir -p /data
liumiaocn:~ root# 
</code></pre>
<h3><a class="header" href="#注意事项" id="注意事项">注意事项</a></h3>
<p>注意此种方式如果重启，mount设定的/的write属性就会失去</p>
<pre><code class="language-shell">liumiaocn:~ root# ls /data
liumiaocn:~ root# mkdir -p /test
mkdir: /test: Read-only file system
liumiaocn:~ root# csrutil status
System Integrity Protection status: disabled.
liumiaocn:~ root# 
</code></pre>
<p>这种情况下可以使用软连接的方式解决这个问题</p>
<pre><code class="language-shell">liumiaocn:/ root# mount -uw /
liumiaocn:/ root# rm -rf /data/
liumiaocn:/ root# mkdir -p /usr/local/data
liumiaocn:/ root# 
</code></pre>
<p>创建软连接</p>
<pre><code class="language-shell">liumiaocn:/ root# ln -s /usr/local/data /data
liumiaocn:/ root# ls -l /data
lrwxr-xr-x  1 root  admin  15 Feb 15 16:32 /data -&gt; /usr/local/data
liumiaocn:/ root#
</code></pre>
<p>这样在重启之后就没有问题了，详细可参看如下日志：</p>
<pre><code class="language-shell">liumiaocn:~ root# mkdir /test
mkdir: /test: Read-only file system
liumiaocn:~ root# cd /data
liumiaocn:data root# mkdir test
liumiaocn:data root# ls
test
liumiaocn:data root# 
</code></pre>
<p>————————————————
版权声明：本文为CSDN博主「liumiaocn」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/liumiaocn/article/details/104324664</p>
<h1><a class="header" href="#macos系统空间占用过大" id="macos系统空间占用过大">macOS系统空间占用过大</a></h1>
<h3><a class="header" href="#开发工具" id="开发工具">开发工具</a></h3>
<h5><a class="header" href="#xcode" id="xcode">Xcode</a></h5>
<blockquote>
<p>核心思想将文件转移到其它空间，再链接到原有目录</p>
</blockquote>
<ol>
<li>执行命令<code>cd /</code></li>
<li>执行命令<code>du -sh *</code>查找哪些目录下有大文件</li>
<li>找到后确认能删除就删除，如果不能删除就使用命令<code>ln -s</code>将大文件迁出系统空间</li>
<li>用iOS举例，最大的文件就是模拟器文件，目录<code>/Library/Developer/CoreSimulator/Profiles/Runtimes</code>，将此目录<code>mv -r</code>到其它空间(如：<code>/Volumn/dev/ios/Runtimes</code>)，移动时间取决于文件大小</li>
<li>这时<code>/Library/Developer/CoreSimulator/Profiles</code>已经为空，使用命令<code>ln -s /Volumn/dev/ios/Runtimes ./</code>生成一个链接文件</li>
<li>启动xcode模拟器，校验是否正常</li>
</ol>
<h5><a class="header" href="#android-studio" id="android-studio">Android Studio</a></h5>
<blockquote>
<p>android将SDK目录和AVD迁移出即可，步骤如上类似</p>
</blockquote>
<h3><a class="header" href="#使用omnidisksweeper免费应用" id="使用omnidisksweeper免费应用">使用OmniDiskSweeper免费应用</a></h3>
<blockquote>
<p>计算所有目录下的文件大小</p>
</blockquote>
<ol>
<li>打开应用，让它计算所有文件夹的大小。</li>
<li>根据文件夹大小，找出最占空间的文件夹。</li>
</ol>
<pre><code>HomeBrew占用较大，主要是.git文件夹巨大，直接删除文件夹内的文件。
Docker应用，docker.raw空间占用巨大，先修改空间大小，再移动此文件到非系统磁盘目录。
</code></pre>
<blockquote>
<p>展示我安装的macOS软件，都是免费，无破解无收费</p>
</blockquote>
<h2><a class="header" href="#文本工具" id="文本工具">文本工具</a></h2>
<ul>
<li><strong>CotEditor</strong>，文本编辑，功能比较强大，免费</li>
<li><strong>Typora</strong>，markdown文本编辑，非常强大，免费可升级</li>
<li><strong>LibreOffice</strong>，word、excel、ppt等文档编辑，免费使用，有增值收费功能</li>
<li><strong>MindLine</strong>，一个封装了百度思维导图的编辑工具，免费</li>
<li><strong>SwitchHosts!</strong>，系统hosts编辑工具，方便开发使用切换hosts，免费</li>
</ul>
<h2><a class="header" href="#文件传输" id="文件传输">文件传输</a></h2>
<ul>
<li><strong>FileZilla</strong>，文件传输，支持ftp、sftp等，免费</li>
<li><strong>Sourcetree</strong>，git客户端，支持github、gitlab，免费</li>
</ul>
<h2><a class="header" href="#数据库管理" id="数据库管理">数据库管理</a></h2>
<ul>
<li><strong>Navicat</strong>，mysql客户端，免费不维护</li>
<li><strong>P3X Redis UI</strong>，redis客户端，免费</li>
</ul>
<h2><a class="header" href="#代码开发" id="代码开发">代码开发</a></h2>
<ul>
<li><strong>Intellij IDEA</strong>，java开发IDE，收费（<em>可使用EAP免费</em>）</li>
<li><strong>CLion</strong>，rust开发IDE，收费（<em>可使用EAP免费</em>）</li>
<li><strong>Android Studio</strong>，android应用开发，免费</li>
<li><strong>Xcode</strong>，iOS应用开发，免费</li>
<li><strong>Visual Studio Code</strong>，文本开发，支持插件安装，免费</li>
</ul>
<p>##SSH工具</p>
<ul>
<li><strong>Termius</strong>，ssh连接工具，免费版无sftp等功能，只有命令行就够用</li>
</ul>
<h2><a class="header" href="#远程api调试工具" id="远程api调试工具">远程api调试工具</a></h2>
<ul>
<li><strong>Postman</strong>，请求调试工具，免费强悍</li>
</ul>
<h2><a class="header" href="#刷新dns缓存" id="刷新dns缓存">刷新DNS缓存</a></h2>
<pre><code class="language-shell">sudo killall -HUP mDNSResponder
sudo killall mDNSResponderHelper
sudo dscacheutil -flushcache
</code></pre>
<blockquote>
<p>Fork是一款免费的git图形客户端，功能强大。由于sourcetree使用的时候需要注册一个账号，一直无法注册，就改使用了Fork，没想到还有意外收获🙂。</p>
</blockquote>
<ol>
<li>点击菜单<code>File - New Tab</code>可以切换不同的仓库。</li>
<li>点击菜单<code>File - Clone…</code>克隆***.git仓库代码。</li>
<li>点击菜单<code>Repository</code>有git最基本常用的操作。</li>
<li>菜单<code>Respository - Git Flow</code>提供git flow流程化操作。</li>
<li>菜单<code>Repository - Git LFS</code>提供大文件处理方式。</li>
<li>主界面左侧有五个栏目</li>
</ol>
<pre><code class="language-javascript">All - 展示所有仓库
Recent - 最近使用的仓库
Bitbucket - Bitbucket登录仓库、展示账户信息
GitHub - GitHub登录仓库、展示账户信息
GitLab - GitLab登录仓库、展示账户信息
</code></pre>
<ol start="7">
<li>主界面All模式，中间展示仓库列表，双击已经clone完成的仓库进入</li>
<li>仓库内</li>
</ol>
<pre><code class="language-javascript">左侧 - 仓库的基本结构，可以用鼠标右键点击执行操作
右侧(上) - git log记录，可以用鼠标右键点击执行操作
右侧(下) - 点击git log记录后，展示响应的信息(Commit当时提交文件，Changes当时提交文件改变内容对比，File Tree当时提交的文件树)
</code></pre>
<ol start="9">
<li>使用pull request</li>
</ol>
<blockquote>
<p>可以发起代码合并申请，让审核代码人进行review</p>
</blockquote>
<pre><code class="language-markdown">仓库内
左侧
1. 展开Remotes
2. 右键点击要发起pull request的分支
3. 点击Create Pull Request on GitHub.com...
4. 在弹出框内点击Send Pull Request
5. OK
</code></pre>
<blockquote>
<p>开发时，当safari地址栏输入<strong>http</strong>://localhost，却跳转到<strong>https</strong>://localhost的问题，百思不得其解。搜索baidu毛都没有。</p>
</blockquote>
<p>解决方案如下：</p>
<ol>
<li>打开safari</li>
<li>快捷键<code>command + ,</code></li>
<li>隐私 -&gt; 管理网站数据</li>
<li>搜索<code>localhost</code></li>
<li>点击<code>移除</code></li>
</ol>
<h4><a class="header" href="#参考" id="参考">参考</a></h4>
<ul>
<li><a href="https://apple.stackexchange.com/questions/215077/safari-redirecting-http-to-non-existent-https">Safari Redirecting http to (non-existent) https</a></li>
</ul>
<h4><a class="header" href="#学习" id="学习">学习</a></h4>
<h2><a class="header" href="#什么是hsts" id="什么是hsts">什么是HSTS？</a></h2>
<h3><a class="header" href="#1-strict-transport-security" id="1-strict-transport-security">1. Strict-Transport-Security</a></h3>
<p><a href="http://tools.ietf.org/html/rfc6797">HTTP Strict Transport Security</a>，简称为HSTS。它允许一个HTTPS网站，要求浏览器总是通过HTTPS来访问它。现阶段，除了Chrome浏览器，Firefox4+，以及Firefox的NoScript扩展都支持这个响应头。</p>
<p>我们知道HTTPS相对于HTTP有更好的安全性，而很多HTTPS网站，也可以通过HTTP来访问。开发人员的失误或者用户主动输入地址，都有可能导致用户以HTTP访问网站，降低了安全性。一般，我们会通过Web Server发送301/302重定向来解决这个问题。现在有了HSTS，可以让浏览器帮你做这个跳转，省一次HTTP请求。</p>
<p>要使用HSTS，只需要在你的<strong>HTTPS</strong>网站响应头中，加入下面这行：</p>
<pre><code class="language-http">strict-transport-security: max-age=16070400; includeSubDomains
</code></pre>
<p>includeSubDomains是可选的，用来指定是否作用于子域名。支持HSTS的浏览器遇到这个响应头，会把当前网站加入HSTS列表，然后在max-age指定的秒数内，当前网站所有请求都会被重定向为https。即使用户主动输入http://或者不输入协议部分，都将重定向到https://地址。</p>
<p>Chrome内置了一个HSTS列表，默认包含Google、Paypal、Twitter、Linode等等服务。我们也可以在Chrome输入chrome://net-internals/#hsts，进入HSTS管理界面。在这个页面，你可以增加/删除/查询HSTS记录。例如，你想一直以https访问某网址，通过“add Domain”加上去就好了。查看Chrome内置的全部HSTS列表，或者想把自己的网站加入这个列表，请<a href="http://www.chromium.org/sts">点这里</a>。</p>
<h3><a class="header" href="#2-x-frame-options" id="2-x-frame-options">2. X-Frame-Options</a></h3>
<p><a href="http://tools.ietf.org/html/draft-ietf-websec-x-frame-options-01">X-Frame-Options</a>，已经转正为<a href="http://tools.ietf.org/html/draft-ietf-websec-frame-options-00">Frame-Options</a>，但现阶段使用最好还是带上X-。Chrome4+、Firefox3.6.9+、IE8+均支持，详细的浏览器支持情况<a href="https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options?redirectlocale=en-US&amp;redirectslug=The_X-FRAME-OPTIONS_response_header#Browser_compatibility">看这里</a>。使用方式如下：</p>
<pre><code class="language-http">x-frame-options: SAMEORIGIN
</code></pre>
<p>这个响应头支持三种配置：</p>
<ul>
<li>DENY：不允许被任何页面嵌入；</li>
<li>SAMEORIGIN：不允许被本域以外的页面嵌入；</li>
<li>ALLOW-FROM uri：不允许被指定的域名以外的页面嵌入（Chrome现阶段不支持）；</li>
</ul>
<p>如果某页面被不被允许的页面以<iframe>或<frame>的形式嵌入，IE会显示类似于“此内容无法在框架中显示”的提示信息，Chrome和Firefox都会在控制台打印信息。由于嵌入的页面不会加载，这就减少了点击劫持（Clickjacking）的发生。</p>
<h3><a class="header" href="#3-x-xss-protection" id="3-x-xss-protection">3. X-XSS-Protection</a></h3>
<p>顾名思义，这个响应头是用来防范XSS的。较早我是在介绍IE8的文章里看到这个，现在主流浏览器都支持，并且默认都开启了XSS保护，用这个header可以关闭它。它有几种配置：</p>
<ul>
<li>0：禁用XSS保护；</li>
<li>1：启用XSS保护；</li>
<li>1; mode=block：启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）；</li>
</ul>
<p>浏览器提供的XSS保护机制并不完美，但是开启后仍然可以提升攻击难度，总之没有特别的理由，不要关闭它。</p>
<h3><a class="header" href="#4-x-content-type-options" id="4-x-content-type-options">4. X-Content-Type-Options</a></h3>
<p>互联网上的资源有各种类型，通常浏览器会根据响应头的Content-Type字段来分辨它们的类型。例如：&quot;text/html&quot;代表html文档，&quot;image/png&quot;是PNG图片，&quot;text/css&quot;是CSS样式文档。然而，有些资源的Content-Type是错的或者未定义。这时，某些浏览器会启用MIME-sniffing来猜测该资源的类型，解析内容并执行。</p>
<p>例如，我们即使给一个html文档指定Content-Type为&quot;text/plain&quot;，在IE8-中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。通过下面这个响应头可以禁用浏览器的类型猜测行为：</p>
<pre><code class="language-http">X-Content-Type-Options: nosniff
</code></pre>
<p>这个响应头的值只能是nosniff，可用于IE8+和Chrome。另外，它还被Chrome用于扩展下载，<a href="https://developer.chrome.com/extensions/hosting.html">见这里</a>。</p>
<h3><a class="header" href="#5-x-content-security-policy" id="5-x-content-security-policy">5. X-Content-Security-Policy</a></h3>
<p>这个响应头主要是用来定义页面可以加载哪些资源，减少XSS的发生。之前单独介绍过，请点击继续浏览：Content Security Policy介绍。</p>
<h3><a class="header" href="#别人怎么用" id="别人怎么用">别人怎么用</a></h3>
<p>最后，我们来看看几个实际案例：</p>
<p>Google+，使用了这几个本文提到的响应头：</p>
<pre><code class="language-http">BASHx-content-type-options: nosniff  x-frame-options: SAMEORIGIN  x-xss-protection: 1; mode=block
</code></pre>
<p>Twitter使用了这些：</p>
<pre><code class="language-http">BASHstrict-transport-security: max-age=631138519  x-frame-options: SAMEORIGIN  x-xss-protection: 1; mode=block
</code></pre>
<p>PayPal的：</p>
<pre><code class="language-http">BASHX-Frame-Options: SAMEORIGIN  Strict-Transport-Security: max-age=14400
</code></pre>
<p>Facebook则使用了这些（配置了详细的CSP，关闭了XSS保护）：</p>
<pre><code class="language-http">BASHstrict-transport-security: max-age=60  x-content-type-options: nosniff  x-frame-options: DENY  x-xss-protection: 0  content-security-policy: default-src *;script-src https://*.facebook.com http://*.facebook.com https://*.fbcdn.net http://*.fbcdn.net *.facebook.net *.google-analytics.com *.virtualearth.net *.google.com 127.0.0.1:* *.spotilocal.com:* chrome-extension://lifbcibllhkdhoafpjfnlhfpfgnpldfl 'unsafe-inline' 'unsafe-eval' https://*.akamaihd.net http://*.akamaihd.net;style-src * 'unsafe-inline';connect-src https://*.facebook.com http://*.facebook.com https://*.fbcdn.net http://*.fbcdn.net *.facebook.net *.spotilocal.com:* https://*.akamaihd.net ws://*.facebook.com:* http://*.akamaihd.net https://fb.scanandcleanlocal.com:*;
</code></pre>
<pre><code class="language-shell">#之前安装过其他版本，可以先全部移除开发工具
sudo rm -rf /Library/Developer/CommandLineTools
#安装
xcode-select --install
#tip:切换版本
sudo xcode-select -switch /Library/Developer/CommandLineTools/
#如果后来你安装了Xcode，可以切回
# Change the path if you installed Xcode somewhere else.
sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
</code></pre>
<h2><a class="header" href="#rust-安装" id="rust-安装">Rust 安装</a></h2>
<h4><a class="header" href="#使用vscode" id="使用vscode">使用vscode</a></h4>
<ol>
<li>安装rust插件</li>
<li>安装rustup</li>
<li>重启vscode，安装rust server</li>
</ol>
<h4><a class="header" href="#debug" id="debug">debug</a></h4>
<p>安装<code>CodeLLDB</code>插件，如果有发生<em>Acquiring CodeLLDB platform package</em>，执行<a href="https://github.com/vadimcn/vscode-lldb/releases/">离线下载</a>对应版本。在扩展里，选择<code>···</code>，选择<code>从VSIX安装</code>，选择下载好的<code>*.vsix</code>文件，安装重启。</p>
<h4><a class="header" href="#问题rustup下载慢" id="问题rustup下载慢">问题：rustup下载慢</a></h4>
<pre><code class="language-shell"># 执行如下两行在命令行中
export RUSTUP_DIST_SERVER=&quot;https://mirrors.ustc.edu.cn/rust-static&quot;
export RUSTUP_UPDATE_ROOT=&quot;https://mirrors.ustc.edu.cn/rust-static/rustup&quot;
</code></pre>
<p>修改后，继续执行安装。</p>
<h2><a class="header" href="#cargo国内源" id="cargo国内源">Cargo国内源</a></h2>
<ul>
<li>清华tuna源</li>
<li>中科大ustc源</li>
</ul>
<pre><code class="language-shell">[source.crates-io]
replace-with = 'tuna'

[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;

[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;
</code></pre>
<h2><a class="header" href="#rust升级" id="rust升级">Rust升级</a></h2>
<h4><a class="header" href="#rustup-update更新慢" id="rustup-update更新慢">rustup update更新慢</a></h4>
<pre><code class="language-shell"># 执行如下命令，该命令只是一段，全部内容去清华mirror的rust页面中查看
vi ~/.bash_profile
export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup rustup install stable
</code></pre>
<p>或者</p>
<pre><code class="language-shell">vi ~/.bash_profile
export RUSTUP_DIST_SERVER=http://mirrors.rustcc.cn
export RUSTUP_UPDATE_ROOT=http://mirrors.rustcc.cn/rustup rustup install stable
</code></pre>
<p>或者</p>
<pre><code class="language-shell">vi ~/.bash_profile
export RUSTUP_UPDATE_ROOT=http://mirrors.ustc.edu.cn/rust-static/rustup
export RUSTUP_DIST_SERVER=http://mirrors.ustc.edu.cn/rust-static
</code></pre>
<p><code>source ~/.bash_profile</code>再次执行更新即可。</p>
<h2><a class="header" href="#rust交叉编译" id="rust交叉编译">Rust交叉编译</a></h2>
<p>开发在Mac，产品最后运行在Linux。两种环境编译的二进制包是无法在彼此环境上运行的。</p>
<h4><a class="header" href="#macos编译linux运行" id="macos编译linux运行">macOS编译，linux运行</a></h4>
<pre><code class="language-shell">x# 查看可用的目标环境rustup target list# 引入linux静态编译包rustup target add x86_64-unknown-linux-musl# 执行编译	cargo build --release --target=x86_64-unknown-linux-muslFinished release [optimized] target(s) in 54.64s####################################################### 说明编译成功！！！# 在target/x86_64-unknown-linux-musl/release目录内获得。######################################################shell
</code></pre>
<h4><a class="header" href="#编译过程中发生错误" id="编译过程中发生错误">编译过程中发生错误</a></h4>
<h5><a class="header" href="#提示binsh-musl-gcc-command-not-found" id="提示binsh-musl-gcc-command-not-found">提示：/bin/sh: musl-gcc: command not found</a></h5>
<pre><code class="language-shell"># 安装
brew install filosottile/musl-cross/musl-cross

# 编辑cargo
vi $HOME/.cargo/config
# 加入如下内容，保存
[target.x86_64-unknown-linux-musl]
linker = &quot;x86_64-linux-musl-gcc&quot;

# 执行目标linux平台的编译命令
# 如果提示OPENSSL_DIR unset，但是环境变量一直都可用，解决方案是把OPENSSL_DIR=&quot;/usr/local/opt/openssl@1.1&quot; 加入到命令前面
CC_x86_64_unknown_linux_musl=&quot;x86_64-linux-musl-gcc&quot; cargo build --release --target=x86_64-unknown-linux-musl
</code></pre>
<h5><a class="header" href="#提示openssl-err的错误" id="提示openssl-err的错误">提示：openssl err的错误</a></h5>
<pre><code class="language-shell"># 安装openssl 1.1
brew install openssl@1.1

# 修改环境变量
vi ~/.bash_profile
export OPENSSL_DIR=&quot;/usr/local/opt/openssl@1.1&quot; # 根据实际目录填写，这是brew默认安装目录
# 保存退出

# 执行source完成
source ~/.bash_profile
</code></pre>
<h5><a class="header" href="#提示ring-xxxxx编译问题没有找到文件或目录" id="提示ring-xxxxx编译问题没有找到文件或目录">提示ring-x.xx.xx编译问题，没有找到文件或目录</a></h5>
<pre><code class="language-shell"># 切换为清华源tuna
[source.crates-io]
replace-with = 'tuna'

[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;
</code></pre>
<p>参考：<a href="https://www.qttc.net/529-rust-cross-compile-mac-to-linux.html">https://www.qttc.net/529-rust-cross-compile-mac-to-linux.html</a></p>
<p>参考：<a href="https://blog.csdn.net/u013195275/article/details/106070326/">https://blog.csdn.net/u013195275/article/details/106070326/</a></p>
<h2><a class="header" href="#rust语法" id="rust语法">Rust语法</a></h2>
<h3><a class="header" href="#1-rust目录" id="1-rust目录">1. Rust目录</a></h3>
<h4><a class="header" href="#11-平级目录" id="11-平级目录">1.1 平级目录</a></h4>
<ul>
<li>src
<ul>
<li>main.rs</li>
<li>api.rs</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">// main.rs
mod api; // 平级引入api.rs 

fn main() {
  api::hello();
}
</code></pre></pre>
<h4><a class="header" href="#12-非平级目录" id="12-非平级目录">1.2 非平级目录</a></h4>
<ul>
<li>src
<ul>
<li>main.rs</li>
<li>api
<ul>
<li>mod.rs</li>
<li>api.rs</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// mod.rs
mod api; // 引入api.rs，注意作用域pub
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.rs
mod api; // 引入api包，注意作用域pub，rust自动查找目录下的mod.rs、lib.rs等
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#13-任意目录" id="13-任意目录">1.3 任意目录</a></h4>
<pre><pre class="playground"><code class="language-rust">use crate::api::api::hello;

fn main() {
  hello();
}
</code></pre></pre>
<h3><a class="header" href="#2-actix-web使用" id="2-actix-web使用">2. actix-web使用</a></h3>
<h4><a class="header" href="#21-http的postgetdeleteput" id="21-http的postgetdeleteput">2.1 http的post\get\delete\put</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get method
// path
#[get(&quot;/advs/{id}&quot;)]
pub async fn detail(_id: web::Path&lt;u32&gt;) -&gt; Result&lt;HttpResponse, Error&gt; {
    Ok(HttpResponse::Ok().body(format!(&quot;hello id:{}&quot;, _id)))
}
// query
#[get(&quot;/advs&quot;)]
pub async fn list(page: web::Query&lt;Page&gt;) -&gt; Result&lt;HttpResponse, Error&gt; {
    Ok(HttpResponse::Ok().body(format!(&quot;hello page:{}&quot;, &amp;page)))
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// post method
// form
#[post(&quot;/advs&quot;)]
pub async fn add(page: web::Form&lt;Page&gt;) -&gt; Result&lt;HttpResponse, Error&gt; {
    Ok(HttpResponse::Ok().body(format!(&quot;hello page:{}&quot;, &amp;page)))
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#3-sqlx时间datetimeutc问题解决方式" id="3-sqlx时间datetimeutc问题解决方式">3. sqlx时间DateTime<Utc>问题解决方式</a></h3>
<p><em>这个问题sqlx还没有解决方案，只能从业务代码中转换。</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用FixedOffset将时区变为+08:00
let created_at: NaiveDateTime = row.get(&quot;created_at&quot;);
let updated_at: NaiveDateTime = row.get(&quot;updated_at&quot;);
let tz_offset = FixedOffset::east(8 * 3600);
let created_at: DateTime&lt;FixedOffset&gt; = tz_offset.from_local_datetime(&amp;created_at).unwrap();
let updated_at: DateTime&lt;FixedOffset&gt; = tz_offset.from_local_datetime(&amp;updated_at).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p><strong>或</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ct: DateTime&lt;Utc&gt; = row.get(&quot;create_time&quot;);
ct.with_timezone(&amp;FixedOffset::east(8*3600));
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#4-如何运行没有cargotoml的examplesxxxrs文件" id="4-如何运行没有cargotoml的examplesxxxrs文件">4. 如何运行没有cargo.toml的examples/xxx.rs文件</a></h3>
<pre><code class="language-shell"># 项目根目录下执行
# 例如：warp
cargo run --example xxx
</code></pre>
<blockquote>
<p>git平台有多个的时候，sshkeys使用同一个不是很安全</p>
</blockquote>
<h3><a class="header" href="#多sshkeys设置" id="多sshkeys设置">多Sshkeys设置</a></h3>
<ol>
<li>生成gitlab sshkeys</li>
</ol>
<pre><code class="language-shell">ssh-keygen -t rsa -C &quot;你的邮箱&quot; -f ~/.ssh/id_rsa_gitlab

# 一路回车
</code></pre>
<ol start="2">
<li>生成github sshkeys</li>
</ol>
<pre><code class="language-shell">ssh-keygen -t rsa -C &quot;你的邮箱&quot; -f ~/.ssh/id_rsa_github

# 一路回车
</code></pre>
<ol start="3">
<li>进入<code>.ssh</code>目录</li>
</ol>
<pre><code class="language-shell">cd ~/.ssh

# 目录内会有四个文件
id_rsa_gitlab id_rsa_gitlab.pub id_rsa_github id_rsa_github.pub
</code></pre>
<ol start="4">
<li>执行agent</li>
</ol>
<pre><code class="language-shell">ssh-agent -s 
</code></pre>
<ol start="5">
<li>添加私钥</li>
</ol>
<pre><code class="language-shell">ssh-add id_rsa_gitlab
ssh-add id_rsa_github

# 添加成功，提示Identity added: ./id_rsa_xxxx (xxxx@xxx.com)
</code></pre>
<ol start="6">
<li>查看是否添加成功</li>
</ol>
<pre><code class="language-shell">ssh-add -l

# 会有两条内容，代表成功添加
</code></pre>
<ol start="7">
<li>修改~/.ssh/config文件，没有就创建</li>
</ol>
<pre><code class="language-shell"># gitlab
Host gitlab.com
HostName gitlab.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_gitlab

# github
Host github.com
HostName github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_github
</code></pre>
<ol start="8">
<li>
<p>将对应的id_rsa_xxxx.pub内容添加到xxxx.com的Ssh keys设置中</p>
</li>
<li>
<p>验证设置是否准确</p>
</li>
</ol>
<pre><code class="language-shell"># 检查github
ssh -T git@github.com 
# 成功提示
# Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 

# 检查gitlab
ssh -T git@gitlab.com 
# 成功提示
# Welcome to GitLab, @xxx! 
</code></pre>
<p>现在就可以使用ssh进行git clone了~~</p>
<h3><a class="header" href="#可能会用到的命令" id="可能会用到的命令">可能会用到的命令</a></h3>
<pre><code class="language-shell"># 删除所有已经添加的id_rsa_xxxx
ssh-add -D
</code></pre>
<h3><a class="header" href="#参考文献" id="参考文献">参考文献</a></h3>
<ul>
<li>
<p><a href="https://www.cnblogs.com/godfeer/p/12214301.html">Git高级之配置多个SSH key</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/p/7d57ce4147d3">解决git@github.com: Permission denied (publickey). Could not read from remote repository.</a></p>
</li>
</ul>
<h2><a class="header" href="#解决github的rawgithubusercontentcom无法连接问题" id="解决github的rawgithubusercontentcom无法连接问题">解决GitHub的raw.githubusercontent.com无法连接问题</a></h2>
<ol>
<li>访问https://site.ip138.com/raw.githubusercontent.com/</li>
<li>输入raw.githubusercontent.com</li>
<li>复制一个地理位置近的ip</li>
<li>粘贴到hosts中，例如：<code>151.101.76.133 raw.githubusercontent.com</code></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
